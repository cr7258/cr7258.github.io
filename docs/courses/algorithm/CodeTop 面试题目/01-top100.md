---
title: Top 100 算法题
author: Se7en
categories:
  - Algorithm
tags:
  - Algorithm
---

## [两数之和](https://leetcode.cn/problems/two-sum/description/)

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出**和为目标值** `target` 的那**两个**整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。

你可以按任意顺序返回答案。

示例 1：

```go
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```

示例 2：

```go
输入：nums = [3,2,4], target = 6
输出：[1,2]
```

示例 3：

```go
输入：nums = [3,3], target = 6
输出：[0,1]
```

**题解**

我们可以通过哈希表来优化问题的求解，使其时间复杂度降低到 O(n)。具体思路如下：
- 创建一个哈希表，键是数组中的数字，值是该数字的下标。
- 在遍历数组时，针对每个数字 v，我们检查哈希表中是否存在 target - v，即目标值减去当前数字的差值。如果存在，那么这两个数的和正好等于 target，返回它们的下标即可。
- 如果没有找到合适的数字，则将当前数字和它的下标存入哈希表，供后续元素查找使用，并进入下一次循环。

```go
func twoSum(nums []int, target int) []int {
	// 键是数字，值是 nums 数组的下标
	hashTable := make(map[int]int)
	for i, v := range nums {
		// 在哈希表中查找的数字，target 减去当前的数字
		if p, ok := hashTable[target-v]; ok {
			return []int{p, i}
		}
		// 没有找到就把当前数字存入哈希表
		hashTable[v] = i
	}
	return nil
}
```

## [三数之和](https://leetcode.cn/problems/3sum/description/)

给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请你返回所有和为 0 且不重复的三元组。

注意：答案中不可以包含重复的三元组。

示例 1：

```
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
解释：
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。
不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。
注意，输出的顺序和三元组的顺序并不重要。
```

示例 2：

```
输入：nums = [0,1,1]
输出：[]
解释：唯一可能的三元组和不为 0 。
```

示例 3：

```
输入：nums = [0,0,0]
输出：[[0,0,0]]
解释：唯一可能的三元组和为 0 。
```

**题解**（排序 + 双指针）

先对数组排序，设一非递减的数组示例和初始三指针位置及名字如下所示。固定 i，即可转换为寻找满足 nums[l]+nums[r]=−nums[i] 的三元组。

![](https://chengzw258.oss-cn-beijing.aliyuncs.com/Article/202410072137251.png)

总共 3 个循环，第 1 个循环枚举 i，第 2 个循环枚举 l，l 每次从 i + 1 开始从左往右遍历数组，第 3 个循环枚举 r，r 每次从 n - 1 开始从右往左遍历数组，寻找满足 nums[l]+nums[r]=−nums[i] 的三元组。
第二重循环和第三重循环实际上是并列的关系，因此最终的时间复杂度是 O(n^2)。

还要注意因为不能包含重复的三元组，所以在移动指针的时候，需要规避连续的重复元素。

```go
func threeSum(nums []int) [][]int {
	n := len(nums)
	// 先将数组排序
	sort.Ints(nums)
	ans := make([][]int, 0)

	// 枚举 i
	for i := 0; i < n; i++ {
		// 需要和上一次枚举的数不相同
		if i > 0 && nums[i] == nums[i-1] {
			continue
		}
		// r 对应的指针初始指向数组的最右端
		r := n - 1
		target := -1 * nums[i]
		// 枚举 b
		for l := i + 1; l < n; l++ {
			// 需要和上一次枚举的数不相同
			if l > i+1 && nums[l] == nums[l-1] {
				continue
			}
			// 需要保证 l 的指针在 r 的指针的左侧
			for l < r && nums[l]+nums[r] > target {
				r--
			}
			// 如果指针重合，随着 l 后续的增加
			// 就不会有满足 i+l+r=0 并且 l<r，可以退出循环
			if l == r {
				break
			}
			if nums[l]+nums[r] == target {
				ans = append(ans, []int{nums[i], nums[l], nums[r]})
			}
		}
	}
	return ans
}
```

## [合并两个有序数组](https://leetcode.cn/problems/merge-sorted-array/description/)

给你两个按**非递减顺序**排列的整数数组 `nums1` 和 `nums2`，另有两个整数 `m` 和 `n` ，分别表示 `nums1` 和 `nums2` 中的元素数目。

请你**合并** `nums2` 到 `nums1` 中，使合并后的数组同样按**非递减顺序**排列。

注意：最终，合并后数组不应由函数返回，而是存储在数组 `nums1` 中。为了应对这种情况，`nums1` 的初始长度为 `m + n`，其中前 `m` 个元素表示应合并的元素，后 `n` 个元素为 `0` ，应忽略。`nums2` 的长度为 `n` 。

示例 1：

```
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
解释：需要合并 [1,2,3] 和 [2,5,6] 。
合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。
```

示例 2：

```
输入：nums1 = [1], m = 1, nums2 = [], n = 0
输出：[1]
解释：需要合并 [1] 和 [] 。
合并结果是 [1] 。
```

示例 3：

```
输入：nums1 = [0], m = 0, nums2 = [1], n = 1
输出：[1]
解释：需要合并的数组是 [] 和 [1] 。
合并结果是 [1] 。
注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。
```

**题解**

原地替换 nums1 数组，初始指针如下图所示，一直向 tail 初赋值，i1 和 i2 指针不断左移。当 nums1[i1] > nums2[i2] 时，令 nums1[tail] = nums1[i1]，i1 左移，反之亦然。

![](https://chengzw258.oss-cn-beijing.aliyuncs.com/Article/202410072258429.png)

```go
func merge(nums1 []int, m int, nums2 []int, n int) {
	i1 := m - 1
	i2 := n - 1
	tail := m + n - 1
	for i1 >= 0 || i2 >= 0 {
		// nums1 数组已经遍历完成，直接将 nums2 数组的值进行追加
		if i1 == -1 {
			nums1[tail] = nums2[i2]
			i2--
		} else if i2 == -1 { // nums2 数组已经遍历完成，直接将 nums1 数组的值进行追加
			nums1[tail] = nums1[i1]
			i1--
		} else if nums1[i1] >= nums2[i2] {
			nums1[tail] = nums1[i1]
			i1--
		} else {
			nums1[tail] = nums2[i2]
			i2--
		}
		tail--
	}
}
```
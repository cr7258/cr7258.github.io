---
title: ç®—æ³•è§£é¢˜å¥—è·¯æ¡†æ¶
author: Se7en
categories:
  - Algorithm
tags:
  - Algorithm
---

# ç®—æ³•è§£é¢˜å¥—è·¯æ¡†æ¶

## å›æº¯

### æ¨¡æ¿

æ— è®ºæ˜¯æ’åˆ—ã€ç»„åˆè¿˜æ˜¯å­é›†é—®é¢˜ï¼Œç®€å•è¯´æ— éå°±æ˜¯è®©ä½ ä»åºåˆ— nums ä¸­ä»¥ç»™å®šè§„åˆ™å–è‹¥å¹²å…ƒç´ ï¼Œä¸»è¦æœ‰ä»¥ä¸‹å‡ ç§å˜ä½“ï¼š

- **1.å…ƒç´ æ— é‡ä¸å¯å¤é€‰**ï¼Œå³ nums ä¸­çš„å…ƒç´ éƒ½æ˜¯å”¯ä¸€çš„ï¼Œæ¯ä¸ªå…ƒç´ æœ€å¤šåªèƒ½è¢«ä½¿ç”¨ä¸€æ¬¡ï¼Œè¿™ä¹Ÿæ˜¯æœ€åŸºæœ¬çš„å½¢å¼ã€‚ä»¥ç»„åˆä¸ºä¾‹ï¼Œå¦‚æœè¾“å…¥ nums = [2,3,6,7]ï¼Œå’Œä¸º 7 çš„ç»„åˆåº”è¯¥åªæœ‰ [7]ã€‚

```go
// ç»„åˆ/å­é›†é—®é¢˜å›æº¯ç®—æ³•æ¡†æ¶ 
func backtrack(nums []int, start int) {
    // å›æº¯ç®—æ³•æ ‡å‡†æ¡†æ¶ 
    for i := start; i < len(nums); i++ {
        // åšé€‰æ‹©
        track = append(track, nums[i])
        // æ³¨æ„å‚æ•° 
        backtrack(nums, i+1)
        // æ’¤é”€é€‰æ‹© 
        track = track[:len(track)-1]
    }
}

// æ’åˆ—é—®é¢˜å›æº¯ç®—æ³•æ¡†æ¶
func backtrack(nums []int) {
    for i := 0; i < len(nums); i++ {
        // å‰ªæé€»è¾‘ 
        if used[i] {
            continue
        }
        // åšé€‰æ‹© 
        used[i] = true
        track = append(track, nums[i])

        backtrack(nums)
        // æ’¤é”€é€‰æ‹© 
        track = track[:len(track)-1]
        used[i] = false
    }
}
```

- **2.å…ƒç´ å¯é‡ä¸å¯å¤é€‰**ï¼Œå³ nums ä¸­çš„å…ƒç´ å¯ä»¥å­˜åœ¨é‡å¤ï¼Œæ¯ä¸ªå…ƒç´ æœ€å¤šåªèƒ½è¢«ä½¿ç”¨ä¸€æ¬¡ã€‚ä»¥ç»„åˆä¸ºä¾‹ï¼Œå¦‚æœè¾“å…¥ nums = [2,5,2,1,2]ï¼Œå’Œä¸º 7 çš„ç»„åˆåº”è¯¥æœ‰ä¸¤ç§ [2,2,2,1] å’Œ [5,2]ã€‚

```go
sort.Ints(nums)
// ç»„åˆ/å­é›†é—®é¢˜å›æº¯ç®—æ³•æ¡†æ¶
func backtrack(nums []int, start int) {
    // å›æº¯ç®—æ³•æ ‡å‡†æ¡†æ¶
    for i := start; i < len(nums); i++ {
        // å‰ªæé€»è¾‘ï¼Œè·³è¿‡å€¼ç›¸åŒçš„ç›¸é‚»æ ‘æ
        if i > start && nums[i] == nums[i-1] {
            continue
        }
        // åšé€‰æ‹©
        track = append(track, nums[i])
        // æ³¨æ„å‚æ•°
        backtrack(nums, i+1)
        // æ’¤é”€é€‰æ‹©
        track = track[:len(track)-1]
    }
}


sort.Ints(nums)
// æ’åˆ—é—®é¢˜å›æº¯ç®—æ³•æ¡†æ¶
func backtrack(nums []int) {
    for i := 0; i < len(nums); i++ {
        // å‰ªæé€»è¾‘
        if used[i] {
            continue
        }
        // å‰ªæé€»è¾‘ï¼Œå›ºå®šç›¸åŒçš„å…ƒç´ åœ¨æ’åˆ—ä¸­çš„ç›¸å¯¹ä½ç½®
        if i > 0 && nums[i] == nums[i-1] && !used[i-1] {
            continue
        }
        // åšé€‰æ‹©
        used[i] = true
        track = append(track, nums[i])

        backtrack(nums)

        // æ’¤é”€é€‰æ‹©
        track = track[:len(track)-1]
        used[i] = false
    }
}
```

- **3.å…ƒç´ æ— é‡å¯å¤é€‰**ï¼Œå³ nums ä¸­çš„å…ƒç´ éƒ½æ˜¯å”¯ä¸€çš„ï¼Œæ¯ä¸ªå…ƒç´ å¯ä»¥è¢«ä½¿ç”¨è‹¥å¹²æ¬¡ã€‚ä»¥ç»„åˆä¸ºä¾‹ï¼Œå¦‚æœè¾“å…¥ nums = [2,3,6,7]ï¼Œå’Œä¸º 7 çš„ç»„åˆåº”è¯¥æœ‰ä¸¤ç§ [2,2,3] å’Œ [7]ã€‚

```go
// ç»„åˆ/å­é›†é—®é¢˜å›æº¯ç®—æ³•æ¡†æ¶
func backtrack(nums []int, start int) {
    // å›æº¯ç®—æ³•æ ‡å‡†æ¡†æ¶
    for i := start; i < len(nums); i++ {
        // åšé€‰æ‹©
        track = append(track, nums[i])
        // æ³¨æ„å‚æ•°
        backtrack(nums, i)
        // æ’¤é”€é€‰æ‹©
        track = track[:len(track)-1]
    }
}

// æ’åˆ—é—®é¢˜å›æº¯ç®—æ³•æ¡†æ¶
func backtrack(nums []int) {
    for i := 0; i < len(nums); i++ {
        // åšé€‰æ‹©
        track = append(track, nums[i])
        backtrack(nums)
        // æ’¤é”€é€‰æ‹©
        track = track[:len(track)-1]
    }
}
```

### ä¾‹é¢˜

| LeetCode                                                              | éš¾åº¦ | ç±»å‹ |
|--------------------------------------------------------------------------------------------------|------| ----- |
| [78.å­é›†](https://leetcode.cn/problems/subsets/)                                                  | ğŸŸ    | å­é›†ï¼ˆå…ƒç´ æ— é‡ä¸å¯å¤é€‰ï¼‰ |
| [77.ç»„åˆ](https://leetcode.cn/problems/combinations/)                                             | ğŸŸ    |ç»„åˆï¼ˆå…ƒç´ æ— é‡ä¸å¯å¤é€‰ï¼‰ |
| [216.ç»„åˆæ€»å’Œ III](https://leetcode.cn/problems/combination-sum-iii/)                              | ğŸŸ    | ç»„åˆï¼ˆå…ƒç´ æ— é‡ä¸å¯å¤é€‰ï¼‰ |
| [46.å…¨æ’åˆ—](https://leetcode.cn/problems/permutations/)                                           | ğŸŸ    | æ’åˆ—ï¼ˆå…ƒç´ æ— é‡ä¸å¯å¤é€‰ï¼‰ |
| [90.å­é›† II](https://leetcode.cn/problems/subsets-ii/)                                            | ğŸŸ    | å­é›†ï¼ˆå…ƒç´ å¯é‡ä¸å¯å¤é€‰ï¼‰ |
| [40.ç»„åˆæ€»å’Œ II](https://leetcode.cn/problems/combination-sum-ii/)                                 | ğŸŸ    | ç»„åˆï¼ˆå…ƒç´ å¯é‡ä¸å¯å¤é€‰ï¼‰ |
| [47.å…¨æ’åˆ— II](https://leetcode.cn/problems/permutations-ii/)                                     | ğŸŸ    | æ’åˆ—ï¼ˆå…ƒç´ å¯é‡ä¸å¯å¤é€‰ï¼‰ |
| [39.ç»„åˆæ€»å’Œ](https://leetcode.cn/problems/combination-sum/)                                       | ğŸŸ    | ç»„åˆï¼ˆå…ƒç´ æ— é‡å¯å¤é€‰ï¼‰ |
| [22. æ‹¬å·ç”Ÿæˆ](https://leetcode.cn/problems/generate-parentheses/)                                 | ğŸŸ    |  |
| [698. åˆ’åˆ†ä¸ºkä¸ªç›¸ç­‰çš„å­é›†](https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/)         | ğŸŸ    |  |


#### 90.å­é›† IIï¼ˆå…ƒç´ æ— é‡ä¸å¯å¤é€‰ï¼‰

ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ nums ï¼Œæ•°ç»„ä¸­çš„å…ƒç´ äº’ä¸ç›¸åŒ ã€‚è¿”å›è¯¥æ•°ç»„æ‰€æœ‰å¯èƒ½çš„å­é›†ï¼ˆå¹‚é›†ï¼‰ã€‚

è§£é›†ä¸èƒ½åŒ…å«é‡å¤çš„å­é›†ã€‚ä½ å¯ä»¥æŒ‰ä»»æ„é¡ºåºè¿”å›è§£é›†ã€‚

ç¤ºä¾‹ 1ï¼š

```go
è¾“å…¥ï¼šnums = [1,2,3]
è¾“å‡ºï¼š[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
```

æˆ‘ä»¬ä½¿ç”¨ `start` å‚æ•°æ§åˆ¶æ ‘æçš„ç”Ÿé•¿é¿å…äº§ç”Ÿé‡å¤çš„å­é›†ï¼Œç”¨ `track` è®°å½•æ ¹èŠ‚ç‚¹åˆ°æ¯ä¸ªèŠ‚ç‚¹çš„è·¯å¾„çš„å€¼ï¼ŒåŒæ—¶åœ¨å‰åºä½ç½®æŠŠæ¯ä¸ªèŠ‚ç‚¹çš„è·¯å¾„å€¼æ”¶é›†èµ·æ¥ï¼Œå®Œæˆå›æº¯æ ‘çš„éå†å°±æ”¶é›†äº†æ‰€æœ‰å­é›†ã€‚

![](https://chengzw258.oss-cn-beijing.aliyuncs.com/Article/202412241600542.png)

```go
func subsets(nums []int) [][]int {
    var res [][]int
    // è®°å½•å›æº¯ç®—æ³•çš„é€’å½’è·¯å¾„
    var track []int
    
    // å›æº¯ç®—æ³•æ ¸å¿ƒå‡½æ•°ï¼Œéå†å­é›†é—®é¢˜çš„å›æº¯æ ‘
    var backtrack func(int)
    backtrack = func(start int) {
        // å‰åºä½ç½®ï¼Œæ¯ä¸ªèŠ‚ç‚¹çš„å€¼éƒ½æ˜¯ä¸€ä¸ªå­é›†
        res = append(res, append([]int(nil), track...))
        
        // å›æº¯ç®—æ³•æ ‡å‡†æ¡†æ¶
        for i := start; i < len(nums); i++ {
            // åšé€‰æ‹©
            track = append(track, nums[i])
            // é€šè¿‡ start å‚æ•°æ§åˆ¶æ ‘æçš„éå†ï¼Œé¿å…äº§ç”Ÿé‡å¤çš„å­é›†
            backtrack(i + 1)
            // æ’¤é”€é€‰æ‹©
            track = track[:len(track)-1]
        }
    }

    backtrack(0)
    return res
}
```

#### 77.ç»„åˆï¼ˆå…ƒç´ æ— é‡ä¸å¯å¤é€‰ï¼‰

ç»™å®šä¸¤ä¸ªæ•´æ•° n å’Œ kï¼Œè¿”å›èŒƒå›´ [1, n] ä¸­æ‰€æœ‰å¯èƒ½çš„ k ä¸ªæ•°çš„ç»„åˆã€‚

ä½ å¯ä»¥æŒ‰ä»»ä½•é¡ºåºè¿”å›ç­”æ¡ˆã€‚

ç¤ºä¾‹ 1ï¼š

```go
è¾“å…¥ï¼šn = 4, k = 2
è¾“å‡ºï¼š
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
```

è¿™æ˜¯æ ‡å‡†çš„ç»„åˆé—®é¢˜ï¼Œä½†æˆ‘ç»™ä½ ç¿»è¯‘ä¸€ä¸‹å°±å˜æˆå­é›†é—®é¢˜äº†ï¼š

ç»™ä½ è¾“å…¥ä¸€ä¸ªæ•°ç»„ nums = [1,2..,n] å’Œä¸€ä¸ªæ­£æ•´æ•° kï¼Œè¯·ä½ ç”Ÿæˆæ‰€æœ‰å¤§å°ä¸º k çš„å­é›†ã€‚

è¿˜æ˜¯ä»¥ nums = [1,2,3] ä¸ºä¾‹ï¼Œåˆšæ‰è®©ä½ æ±‚æ‰€æœ‰å­é›†ï¼Œå°±æ˜¯æŠŠæ‰€æœ‰èŠ‚ç‚¹çš„å€¼éƒ½æ”¶é›†èµ·æ¥ï¼›ç°åœ¨ä½ åªéœ€è¦æŠŠç¬¬ 2 å±‚ï¼ˆæ ¹èŠ‚ç‚¹è§†ä¸ºç¬¬ 0 å±‚ï¼‰çš„èŠ‚ç‚¹æ”¶é›†èµ·æ¥ï¼Œå°±æ˜¯å¤§å°ä¸º 2 çš„æ‰€æœ‰ç»„åˆï¼š

![](https://chengzw258.oss-cn-beijing.aliyuncs.com/Article/202412241604224.png)

åæ˜ åˆ°ä»£ç ä¸Šï¼Œåªéœ€è¦ç¨æ”¹ base caseï¼Œæ§åˆ¶ç®—æ³•ä»…ä»…æ”¶é›†ç¬¬ k å±‚èŠ‚ç‚¹çš„å€¼å³å¯ï¼š

```go
func combine(n int, k int) [][]int {
    var res [][]int
    // è®°å½•å›æº¯ç®—æ³•çš„é€’å½’è·¯å¾„
    var track []int

    // å›æº¯ç®—æ³•æ ¸å¿ƒå‡½æ•°
    var backtrack func(int)
    backtrack = func(start int) {
        // base case
        if k == len(track) {
            // éå†åˆ°äº†ç¬¬ k å±‚ï¼Œæ”¶é›†å½“å‰èŠ‚ç‚¹çš„å€¼
            res = append(res, append([]int(nil), track...))
            return
        }

        // å›æº¯ç®—æ³•æ ‡å‡†æ¡†æ¶
        for i := start; i <= n; i++ {
            // é€‰æ‹©
            track = append(track, i)
            // é€šè¿‡ start å‚æ•°æ§åˆ¶æ ‘æçš„éå†ï¼Œé¿å…äº§ç”Ÿé‡å¤çš„å­é›†
            backtrack(i + 1)
            // æ’¤é”€é€‰æ‹©
            track = track[:len(track)-1]
        }
    }

    backtrack(1)
    return res
}
```

#### 216.ç»„åˆæ€»å’Œ IIIï¼ˆå…ƒç´ æ— é‡ä¸å¯å¤é€‰ï¼‰

æ‰¾å‡ºæ‰€æœ‰ç›¸åŠ ä¹‹å’Œä¸º n çš„ k ä¸ªæ•°çš„ç»„åˆï¼Œä¸”æ»¡è¶³ä¸‹åˆ—æ¡ä»¶ï¼š

- åªä½¿ç”¨æ•°å­— 1 åˆ° 9
- æ¯ä¸ªæ•°å­—æœ€å¤šä½¿ç”¨ä¸€æ¬¡ 

è¿”å›æ‰€æœ‰å¯èƒ½çš„æœ‰æ•ˆç»„åˆçš„åˆ—è¡¨ã€‚è¯¥åˆ—è¡¨ä¸èƒ½åŒ…å«ç›¸åŒçš„ç»„åˆä¸¤æ¬¡ï¼Œç»„åˆå¯ä»¥ä»¥ä»»ä½•é¡ºåºè¿”å›ã€‚

ç¤ºä¾‹ 1:

```go
è¾“å…¥: k = 3, n = 7
è¾“å‡º: [[1,2,4]]
è§£é‡Š:
1 + 2 + 4 = 7
æ²¡æœ‰å…¶ä»–ç¬¦åˆçš„ç»„åˆäº†ã€‚
```

```go
func combinationSum3(k int, n int) [][]int {
	var res [][]int
	var track []int
	var trackSum int

	var backtrack func(int)
	backtrack = func(start int) {
        // å½“æ»¡è¶³æ¡ä»¶æ—¶ï¼Œæ”¶é›† track çš„å€¼
		if k == len(track) && trackSum == n {
			res = append(res, append([]int(nil), track...))
		}

		if trackSum > n || len(track) > k {
			return
		}

        // ä» start å¼€å§‹éå†åˆ° 9ï¼ˆåªèƒ½ä½¿ç”¨æ•°å­— 1-9ï¼‰
		for i := start; i <= 9; i++ {
			trackSum += i
			track = append(track, i)
			backtrack(i + 1)
			track = track[:len(track)-1]
			trackSum -= i
		}
	}

	backtrack(1)
	return res
}
```

#### 46.å…¨æ’åˆ—ï¼ˆå…ƒç´ æ— é‡ä¸å¯å¤é€‰ï¼‰

ç»™å®šä¸€ä¸ªä¸å«é‡å¤æ•°å­—çš„æ•°ç»„ nums ï¼Œè¿”å›å…¶æ‰€æœ‰å¯èƒ½çš„å…¨æ’åˆ— ã€‚ä½ å¯ä»¥æŒ‰ä»»æ„é¡ºåºè¿”å›ç­”æ¡ˆã€‚

ç¤ºä¾‹ 1ï¼š

```go
è¾“å…¥ï¼šnums = [1,2,3]
è¾“å‡ºï¼š[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

åˆšæ‰è®²çš„ç»„åˆ/å­é›†é—®é¢˜ä½¿ç”¨ `start` å˜é‡ä¿è¯å…ƒç´  `nums[start]` ä¹‹ååªä¼šå‡ºç° `nums[start+1..]` ä¸­çš„å…ƒç´ ï¼Œé€šè¿‡å›ºå®šå…ƒç´ çš„ç›¸å¯¹ä½ç½®ä¿è¯ä¸å‡ºç°é‡å¤çš„å­é›†ã€‚

ä½†æ’åˆ—é—®é¢˜æœ¬èº«å°±æ˜¯è®©ä½ ç©·ä¸¾å…ƒç´ çš„ä½ç½®ï¼Œ`nums[i]` ä¹‹åä¹Ÿå¯ä»¥å‡ºç° `nums[i]` å·¦è¾¹çš„å…ƒç´ ï¼Œæ‰€ä»¥ä¹‹å‰çš„é‚£ä¸€å¥—ç©ä¸è½¬äº†ï¼Œéœ€è¦é¢å¤–ä½¿ç”¨ `used` æ•°ç»„æ¥æ ‡è®°å“ªäº›å…ƒç´ è¿˜å¯ä»¥è¢«é€‰æ‹©ã€‚

æ ‡å‡†å…¨æ’åˆ—å¯ä»¥æŠ½è±¡æˆå¦‚ä¸‹è¿™æ£µå¤šå‰æ ‘ï¼š

![](https://chengzw258.oss-cn-beijing.aliyuncs.com/Article/202412241612892.png)

æˆ‘ä»¬ç”¨ `used` æ•°ç»„æ ‡è®°å·²ç»åœ¨è·¯å¾„ä¸Šçš„å…ƒç´ é¿å…é‡å¤é€‰æ‹©ï¼Œç„¶åæ”¶é›†æ‰€æœ‰å¶å­èŠ‚ç‚¹ä¸Šçš„å€¼ï¼Œå°±æ˜¯æ‰€æœ‰å…¨æ’åˆ—çš„ç»“æœï¼š

```go
func permute(nums []int) [][]int {
    var res [][]int
    // è®°å½•å›æº¯ç®—æ³•çš„é€’å½’è·¯å¾„
    var track []int
    // track ä¸­çš„å…ƒç´ ä¼šè¢«æ ‡è®°ä¸º true
    used := make([]bool, len(nums))

    // å›æº¯ç®—æ³•æ ¸å¿ƒå‡½æ•°
    var backtrace func()
    backtrace = func() {
        // base caseï¼Œåˆ°è¾¾å¶å­èŠ‚ç‚¹
        if len(track) == len(nums) {
            // æ”¶é›†å¶å­èŠ‚ç‚¹ä¸Šçš„å€¼
            res = append(res, append([]int(nil), track...))
            return
        }
        // å›æº¯ç®—æ³•æ ‡å‡†æ¡†æ¶
        for i := 0; i < len(nums); i++ {
            if used[i] {
                continue
            }
            // åšé€‰æ‹©
            used[i] = true
            track = append(track, nums[i])
            // è¿›å…¥ä¸‹ä¸€å±‚å›æº¯æ ‘
            backtrace()
            // å–æ¶ˆé€‰æ‹©
            track = track[:len(track)-1]
            used[i] = false
        }
    }
    backtrace()
    return res
}
```

#### 90.å­é›† IIï¼ˆå…ƒç´ å¯é‡ä¸å¯å¤é€‰ï¼‰

ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ nums ï¼Œå…¶ä¸­å¯èƒ½åŒ…å«é‡å¤å…ƒç´ ï¼Œè¯·ä½ è¿”å›è¯¥æ•°ç»„æ‰€æœ‰å¯èƒ½çš„å­é›†ï¼ˆå¹‚é›†ï¼‰ã€‚

è§£é›†ä¸èƒ½åŒ…å«é‡å¤çš„å­é›†ã€‚è¿”å›çš„è§£é›†ä¸­ï¼Œå­é›†å¯ä»¥æŒ‰ä»»æ„é¡ºåºæ’åˆ—ã€‚

ç¤ºä¾‹ 1ï¼š

```go
è¾“å…¥ï¼šnums = [1,2,2]
è¾“å‡ºï¼š[[],[1],[1,2],[1,2,2],[2],[2,2]]
```

éœ€è¦è¿›è¡Œå‰ªæå»é™¤é‡å¤ç»“æœï¼Œå¦‚æœä¸€ä¸ªèŠ‚ç‚¹æœ‰å¤šæ¡å€¼ç›¸åŒçš„æ ‘æç›¸é‚»ï¼Œåˆ™åªéå†ç¬¬ä¸€æ¡ï¼Œå‰©ä¸‹çš„éƒ½å‰ªæ‰ï¼Œä¸è¦å»éå†ã€‚

![](https://chengzw258.oss-cn-beijing.aliyuncs.com/Article/202412241630544.png)

å…ˆå¯¹å…ƒç´ è¿›è¡Œæ’åºï¼Œè®©ç›¸åŒçš„å…ƒç´ é åœ¨ä¸€èµ·ï¼Œå¦‚æœå‘ç° nums[i] == nums[i-1]ï¼Œåˆ™è·³è¿‡ï¼š

```go
func subsetsWithDup(nums []int) [][]int {
	var res [][]int
    // è®°å½•å›æº¯ç®—æ³•çš„é€’å½’è·¯å¾„
	var track []int
    // å…ˆæ’åºï¼Œè®©ç›¸åŒçš„å…ƒç´ é åœ¨ä¸€èµ·
	sort.Ints(nums)

	var backtrack func(int)
	backtrack = func(start int) {
        // å‰åºä½ç½®ï¼Œæ¯ä¸ªèŠ‚ç‚¹çš„å€¼éƒ½æ˜¯ä¸€ä¸ªå­é›†
		res = append(res, append([]int(nil), track...))

		for i := start; i < len(nums); i++ {
            // å‰ªæé€»è¾‘ï¼Œå€¼ç›¸åŒçš„ç›¸é‚»æ ‘æï¼Œåªéå†ç¬¬ä¸€æ¡
			if i > start && nums[i] == nums[i-1] {
				continue
			}
			track = append(track, nums[i])
			backtrack(i + 1)
			track = track[:len(track)-1]
		}
	}
	backtrack(0)
	return res
}
```

#### 40.ç»„åˆæ€»å’Œ IIï¼ˆå…ƒç´ å¯é‡ä¸å¯å¤é€‰ï¼‰

ç»™å®šä¸€ä¸ªå€™é€‰äººç¼–å·çš„é›†åˆ candidates å’Œä¸€ä¸ªç›®æ ‡æ•° targetï¼Œæ‰¾å‡º candidates ä¸­æ‰€æœ‰å¯ä»¥ä½¿æ•°å­—å’Œä¸º target çš„ç»„åˆã€‚

candidates ä¸­çš„æ¯ä¸ªæ•°å­—åœ¨æ¯ä¸ªç»„åˆä¸­åªèƒ½ä½¿ç”¨ä¸€æ¬¡ ã€‚

æ³¨æ„ï¼šè§£é›†ä¸èƒ½åŒ…å«é‡å¤çš„ç»„åˆã€‚ 

ç¤ºä¾‹ 1:

```go
è¾“å…¥: candidates = [10,1,2,7,6,1,5], target = 8,
è¾“å‡º:
[
[1,1,6],
[1,2,5],
[1,7],
[2,6]
]
```

è¯´è¿™æ˜¯ä¸€ä¸ªç»„åˆé—®é¢˜ï¼Œå…¶å®æ¢ä¸ªé—®æ³•å°±å˜æˆå­é›†é—®é¢˜äº†ï¼šè¯·ä½ è®¡ç®— candidates ä¸­æ‰€æœ‰å’Œä¸º target çš„å­é›†ã€‚

å¯¹æ¯”å­é›†é—®é¢˜çš„è§£æ³•ï¼Œåªè¦é¢å¤–ç”¨ä¸€ä¸ª trackSum å˜é‡è®°å½•å›æº¯è·¯å¾„ä¸Šçš„å…ƒç´ å’Œï¼Œç„¶åå°† base case æ”¹ä¸€æ”¹å³å¯è§£å†³è¿™é“é¢˜ï¼š

```go
func combinationSum2(nums []int, target int) [][]int {
	var res [][]int
	var track []int
    // è®°å½• track ä¸­çš„å…ƒç´ ä¹‹å’Œ
	var trackSum int
    // å…ˆæ’åºï¼Œè®©ç›¸åŒçš„å…ƒç´ é åœ¨ä¸€èµ·
	sort.Ints(nums)

    // å›æº¯ç®—æ³•ä¸»å‡½æ•°
	var backtrack func(int)
	backtrack = func(start int) {
        // base caseï¼Œè¾¾åˆ°ç›®æ ‡å’Œï¼Œæ‰¾åˆ°ç¬¦åˆæ¡ä»¶çš„ç»„åˆ
		if trackSum == target {
			res = append(res, append([]int(nil), track...))
            return
		}
        // base caseï¼Œè¶…è¿‡ç›®æ ‡å’Œï¼Œç›´æ¥ç»“æŸ
		if trackSum > target {
			return
		}
        // å›æº¯ç®—æ³•æ ‡å‡†æ¡†æ¶
		for i := start; i < len(nums); i++ {
            // å‰ªæé€»è¾‘ï¼Œå€¼ç›¸åŒçš„æ ‘æï¼Œåªéå†ç¬¬ä¸€æ¡
			if i > start && nums[i] == nums[i-1] {
				continue
			}
            // åšé€‰æ‹©
			track = append(track, nums[i])
			trackSum += nums[i]
            // é€’å½’éå†ä¸‹ä¸€å±‚å›æº¯æ ‘
			backtrack(i + 1)
            // æ’¤é”€é€‰æ‹©
			track = track[:len(track)-1]
			trackSum -= nums[i]
		}
	}
	backtrack(0)
	return res
}
```

#### 47.å…¨æ’åˆ— IIï¼ˆå…ƒç´ å¯é‡ä¸å¯å¤é€‰ï¼‰

ç»™å®šä¸€ä¸ªå¯åŒ…å«é‡å¤æ•°å­—çš„åºåˆ— nums ï¼ŒæŒ‰ä»»æ„é¡ºåº è¿”å›æ‰€æœ‰ä¸é‡å¤çš„å…¨æ’åˆ—ã€‚

ç¤ºä¾‹ 1ï¼š

```go
è¾“å…¥ï¼šnums = [1,1,2]
è¾“å‡ºï¼š
[[1,1,2],
 [1,2,1],
 [2,1,1]]
``` 

å¯¹æ¯”ä¹‹å‰çš„[æ ‡å‡†å…¨æ’åˆ—è§£æ³•ä»£ç ](#_46-å…¨æ’åˆ—-å…ƒç´ æ— é‡ä¸å¯å¤é€‰)ï¼Œè¿™æ®µè§£æ³•ä»£ç åªæœ‰ä¸¤å¤„ä¸åŒï¼š

- 1.å¯¹ nums è¿›è¡Œäº†æ’åºã€‚
- 2.æ·»åŠ äº†ä¸€å¥é¢å¤–çš„å‰ªæé€»è¾‘ã€‚

```go
func permuteUnique(nums []int) [][]int {
	var res [][]int
	var track []int
    // track ä¸­çš„å…ƒç´ ä¼šè¢«æ ‡è®°ä¸º true
	used := make([]bool, len(nums))
    // å…ˆæ’åºï¼Œè®©ç›¸åŒçš„å…ƒç´ é åœ¨ä¸€èµ·
	sort.Ints(nums)

	var backtrack func()
	backtrack = func() {
		if len(track) == len(nums) {
			res = append(res, append([]int(nil), track...))
            return
		}
        // æ³¨æ„èµ·å§‹æ˜¯ 0ï¼Œæ²¡æœ‰ start
		for i := 0; i < len(nums); i++ {
			if used[i] {
				continue
			}
            // æ–°æ·»åŠ çš„å‰ªæé€»è¾‘ï¼Œå›ºå®šç›¸åŒçš„å…ƒç´ åœ¨æ’åˆ—ä¸­çš„ç›¸å¯¹ä½ç½®
            // è¯´æ˜å½“å‰æ•°å­—ä¸å‰ä¸€ä¸ªæ•°å­—ç›¸åŒï¼Œå¹¶ä¸”å‰ä¸€ä¸ªæ•°å­—å°šæœªè¢«ä½¿ç”¨ï¼Œæ­¤æ—¶è·³è¿‡ä»¥é¿å…é‡å¤æ’åˆ—
			if i > 0 && nums[i] == nums[i-1] && !used[i-1] {
				continue
			}

			used[i] = true
			track = append(track, nums[i])
			backtrack()
			track = track[:len(track)-1]
			used[i] = false
		}
	}
	backtrack()
	return res
}
```

#### 39.ç»„åˆæ€»å’Œï¼ˆå…ƒç´ æ— é‡å¯å¤é€‰ï¼‰

ç»™ä½ ä¸€ä¸ªæ— é‡å¤å…ƒç´ çš„æ•´æ•°æ•°ç»„ candidates å’Œä¸€ä¸ªç›®æ ‡æ•´æ•° targetï¼Œæ‰¾å‡º candidates ä¸­å¯ä»¥ä½¿æ•°å­—å’Œä¸ºç›®æ ‡æ•° target çš„æ‰€æœ‰ä¸åŒç»„åˆï¼Œå¹¶ä»¥åˆ—è¡¨å½¢å¼è¿”å›ã€‚ä½ å¯ä»¥æŒ‰ä»»æ„é¡ºåºè¿”å›è¿™äº›åˆã€‚

candidates ä¸­çš„åŒä¸€ä¸ªæ•°å­—å¯ä»¥æ— é™åˆ¶é‡å¤è¢«é€‰å–ã€‚å¦‚æœè‡³å°‘ä¸€ä¸ªæ•°å­—çš„è¢«é€‰æ•°é‡ä¸åŒï¼Œåˆ™ä¸¤ç§ç»„åˆæ˜¯ä¸åŒçš„ã€‚ 

å¯¹äºç»™å®šçš„è¾“å…¥ï¼Œä¿è¯å’Œä¸º target çš„ä¸åŒç»„åˆæ•°å°‘äº 150 ä¸ªã€‚

ç¤ºä¾‹ 1ï¼š

```go
è¾“å…¥ï¼šcandidates = [2,3,6,7], target = 7
è¾“å‡ºï¼š[[2,2,3],[7]]
è§£é‡Šï¼š
2 å’Œ 3 å¯ä»¥å½¢æˆä¸€ç»„å€™é€‰ï¼Œ2 + 2 + 3 = 7 ã€‚æ³¨æ„ 2 å¯ä»¥ä½¿ç”¨å¤šæ¬¡ã€‚
7 ä¹Ÿæ˜¯ä¸€ä¸ªå€™é€‰ï¼Œ 7 = 7 ã€‚
ä»…æœ‰è¿™ä¸¤ç§ç»„åˆã€‚
```

åœ¨ä¹‹å‰å¤„ç†æ— é‡å¤å…ƒç´ çš„å­é›†/ç»„åˆé—®é¢˜æ—¶ï¼Œæˆ‘ä»¬åœ¨è°ƒç”¨ backtrack å‡½æ•°çš„æ—¶å€™ä¼ å…¥ `i + 1`ï¼Œè¿™ä¸ª i ä» start å¼€å§‹ï¼Œé‚£ä¹ˆä¸‹ä¸€å±‚å›æº¯æ ‘å°±æ˜¯ä» start + 1 å¼€å§‹ï¼Œä»è€Œä¿è¯ nums[start] è¿™ä¸ªå…ƒç´ ä¸ä¼šè¢«é‡å¤ä½¿ç”¨ã€‚

é‚£ä¹ˆåè¿‡æ¥ï¼Œå¦‚æœæˆ‘æƒ³è®©æ¯ä¸ªå…ƒç´ è¢«é‡å¤ä½¿ç”¨ï¼Œæˆ‘åªè¦æŠŠ `i + 1` æ”¹æˆ `i` å³å¯ï¼š

```go
func combinationSum(nums []int, target int) [][]int {
	var res [][]int
    // è®°å½•å›æº¯çš„è·¯å¾„
	var track []int
    // è®°å½• track ä¸­çš„è·¯å¾„å’Œ
    var trackSum int

    var backtrack func(int)
    backtrack = func(start int) {
        // base caseï¼Œæ‰¾åˆ°ç›®æ ‡å’Œï¼Œè®°å½•ç»“æœ
        if trackSum == target {
            res = append(res, append([]int(nil), track...))
            return
        }
        // base caseï¼Œè¶…è¿‡ç›®æ ‡å’Œï¼Œåœæ­¢å‘ä¸‹éå†
        if trackSum > target {
            return
        }

        // å›æº¯ç®—æ³•æ ‡å‡†æ¡†æ¶
        for i := start; i < len(nums); i++ {
            // é€‰æ‹© nums[i]
            trackSum += nums[i]
            track = append(track, nums[i])
            // é€’å½’éå†ä¸‹ä¸€å±‚å›æº¯æ ‘
            // åŒä¸€å…ƒç´ å¯é‡å¤ä½¿ç”¨ï¼Œæ³¨æ„å‚æ•°
            backtrack(i)
            // æ’¤é”€é€‰æ‹© nums[i]
            track = track[:len(track)-1]
            trackSum -= nums[i]
        }
    }

    backtrack(0)
    return res

}
```

#### 22.æ‹¬å·ç”Ÿæˆ

æ•°å­— n ä»£è¡¨ç”Ÿæˆæ‹¬å·çš„å¯¹æ•°ï¼Œè¯·ä½ è®¾è®¡ä¸€ä¸ªå‡½æ•°ï¼Œç”¨äºèƒ½å¤Ÿç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„å¹¶ä¸”æœ‰æ•ˆçš„æ‹¬å·ç»„åˆã€‚

ç¤ºä¾‹ 1ï¼š

```go
è¾“å…¥ï¼šn = 3
è¾“å‡ºï¼š["((()))","(()())","(())()","()(())","()()()"]
```

è¿™é“é¢˜çš„æ ¸å¿ƒæ€è·¯æ˜¯é€šè¿‡é€’å½’å›æº¯ç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„æ‹¬å·ç»„åˆï¼Œå¹¶ç”¨å‰ªææ¡ä»¶ç¡®ä¿åªç”Ÿæˆåˆæ³•çš„ç»„åˆï¼š

- 1. ç”¨ `left` å’Œ `right` åˆ†åˆ«è¡¨ç¤ºå‰©ä½™çš„å·¦æ‹¬å·å’Œå³æ‹¬å·æ•°é‡ã€‚
- 2. å‰ªææ¡ä»¶ï¼šå³æ‹¬å·æ•°é‡ä¸èƒ½å°‘äºå·¦æ‹¬å·ï¼ˆ`right < left`ï¼‰ä¸”æ‹¬å·æ•°é‡ä¸èƒ½å°äº 0ã€‚
- 3. æ¯æ¬¡é€’å½’é€‰æ‹©æ·»åŠ å·¦æ‹¬å·æˆ–å³æ‹¬å·ï¼Œå¹¶åœ¨å·¦å³æ‹¬å·éƒ½ç”¨å®Œæ—¶è®°å½•ç»“æœã€‚

```go
func generateParenthesis(n int) []string {
    var track string
    var res []string

    var backtrack func(left, right int)
    backtrack = func(left, right int) {
        // è‹¥å·¦æ‹¬å·å‰©ä¸‹çš„å¤šï¼Œè¯´æ˜ä¸åˆæ³•
        // å¯ä»¥æ’é™¤æ‰ç±»ä¼¼ ))(( è¿™ç§æ— æ•ˆçš„æ‹¬å·ï¼Œå› ä¸º ))( çš„æ—¶å€™ right < leftï¼Œå·²ç»è¢«æ’é™¤äº†
        if right < left {
            return
        }
        // æ•°é‡å°äº 0 è‚¯å®šæ˜¯ä¸åˆæ³•çš„
        if left < 0 || right < 0 {
            return
        }
        // å½“æ‰€æœ‰æ‹¬å·éƒ½æ°å¥½ç”¨å®Œæ—¶ï¼Œå¾—åˆ°ä¸€ä¸ªåˆæ³•çš„æ‹¬å·ç»„åˆ
        if left == 0 && right == 0 {
            res = append(res, track)
            return
        }

        // åšé€‰æ‹©ï¼Œå°è¯•æ”¾ä¸€ä¸ªå·¦æ‹¬å·
        track += "("
        backtrack(left-1, right)
        // æ’¤é”€é€‰æ‹©
        track = track[:len(track)-1]

        // åšé€‰æ‹©ï¼Œå°è¯•æ”¾ä¸€ä¸ªå³æ‹¬å·
        track += ")"
        backtrack(left, right-1)
        // æ’¤é”€é€‰æ‹©
        track = track[:len(track)-1]
    }

    backtrack(n, n)
    return res
}
```

#### 698. åˆ’åˆ†ä¸ºkä¸ªç›¸ç­‰çš„å­é›†

ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„  nums å’Œä¸€ä¸ªæ­£æ•´æ•° kï¼Œæ‰¾å‡ºæ˜¯å¦æœ‰å¯èƒ½æŠŠè¿™ä¸ªæ•°ç»„åˆ†æˆ k ä¸ªéç©ºå­é›†ï¼Œå…¶æ€»å’Œéƒ½ç›¸ç­‰ã€‚

ç¤ºä¾‹ 1ï¼š

```go
è¾“å…¥ï¼š nums = [4, 3, 2, 3, 5, 2, 1], k = 4
è¾“å‡ºï¼š True
è¯´æ˜ï¼š æœ‰å¯èƒ½å°†å…¶åˆ†æˆ 4 ä¸ªå­é›†ï¼ˆ5ï¼‰ï¼Œï¼ˆ1,4ï¼‰ï¼Œï¼ˆ2,3ï¼‰ï¼Œï¼ˆ2,3ï¼‰ç­‰äºæ€»å’Œã€‚
```

## æ•°ç»„

### å¿«æ…¢æŒ‡é’ˆ

#### åŸåœ°ä¿®æ”¹

##### 26. åˆ é™¤æœ‰åºæ•°ç»„ä¸­çš„é‡å¤é¡¹

ç»™ä½ ä¸€ä¸ªéä¸¥æ ¼é€’å¢æ’åˆ—çš„æ•°ç»„ numsï¼Œè¯·ä½ åŸåœ°åˆ é™¤é‡å¤å‡ºç°çš„å…ƒç´ ï¼Œä½¿æ¯ä¸ªå…ƒç´ åªå‡ºç°ä¸€æ¬¡ï¼Œè¿”å›åˆ é™¤åæ•°ç»„çš„æ–°é•¿åº¦ã€‚å…ƒç´ çš„ç›¸å¯¹é¡ºåºåº”è¯¥ä¿æŒä¸€è‡´ã€‚ç„¶åè¿”å› nums ä¸­å”¯ä¸€å…ƒç´ çš„ä¸ªæ•°ã€‚

è€ƒè™‘ nums çš„å”¯ä¸€å…ƒç´ çš„æ•°é‡ä¸º kï¼Œä½ éœ€è¦åšä»¥ä¸‹äº‹æƒ…ç¡®ä¿ä½ çš„é¢˜è§£å¯ä»¥è¢«é€šè¿‡ï¼š

- æ›´æ”¹æ•°ç»„ numsï¼Œä½¿ nums çš„å‰ k ä¸ªå…ƒç´ åŒ…å«å”¯ä¸€å…ƒç´ ï¼Œå¹¶æŒ‰ç…§å®ƒä»¬æœ€åˆåœ¨ nums ä¸­å‡ºç°çš„é¡ºåºæ’åˆ—ã€‚nums çš„å…¶ä½™å…ƒç´ ä¸ nums çš„å¤§å°ä¸é‡è¦ã€‚
- è¿”å› kã€‚

ç¤ºä¾‹ 1ï¼š

```go
è¾“å…¥ï¼šnums = [1,1,2]
è¾“å‡ºï¼š2, nums = [1,2,_]
è§£é‡Šï¼šå‡½æ•°åº”è¯¥è¿”å›æ–°çš„é•¿åº¦ 2 ï¼Œå¹¶ä¸”åŸæ•°ç»„ nums çš„å‰ä¸¤ä¸ªå…ƒç´ è¢«ä¿®æ”¹ä¸º 1, 2 ã€‚ä¸éœ€è¦è€ƒè™‘æ•°ç»„ä¸­è¶…å‡ºæ–°é•¿åº¦åé¢çš„å…ƒç´ ã€‚
```

æˆ‘ä»¬è®©æ…¢æŒ‡é’ˆ slow èµ°åœ¨åé¢ï¼Œå¿«æŒ‡é’ˆ fast èµ°åœ¨å‰é¢æ¢è·¯ï¼Œæ‰¾åˆ°ä¸€ä¸ªä¸é‡å¤çš„å…ƒç´ å°±èµ‹å€¼ç»™ slow å¹¶è®© slow å‰è¿›ä¸€æ­¥ã€‚

è¿™æ ·ï¼Œå°±ä¿è¯äº† nums[0..slow] éƒ½æ˜¯æ— é‡å¤çš„å…ƒç´ ï¼Œå½“ fast æŒ‡é’ˆéå†å®Œæ•´ä¸ªæ•°ç»„ nums åï¼Œnums[0..slow] å°±æ˜¯æ•´ä¸ªæ•°ç»„å»é‡ä¹‹åçš„ç»“æœã€‚

```go
func removeDuplicates(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    slow,fast :=0,0
    for fast<len(nums) {
        if nums[fast] != nums[slow] {
            slow++
            // ç»´æŠ¤ nums[0..slow] æ— é‡å¤
            nums[slow] = nums[fast]
        }
        fast++
    }
    // æ•°ç»„é•¿åº¦ä¸ºç´¢å¼• + 1
    return slow + 1
}
```

##### 27. ç§»é™¤å…ƒç´ 

ç»™ä½ ä¸€ä¸ªæ•°ç»„ nums å’Œä¸€ä¸ªå€¼ valï¼Œä½ éœ€è¦åŸåœ°ç§»é™¤æ‰€æœ‰æ•°å€¼ç­‰äº val çš„å…ƒç´ ã€‚å…ƒç´ çš„é¡ºåºå¯èƒ½å‘ç”Ÿæ”¹å˜ã€‚ç„¶åè¿”å› nums ä¸­ä¸ val ä¸åŒçš„å…ƒç´ çš„æ•°é‡ã€‚

å‡è®¾ nums ä¸­ä¸ç­‰äº val çš„å…ƒç´ æ•°é‡ä¸º kï¼Œè¦é€šè¿‡æ­¤é¢˜ï¼Œæ‚¨éœ€è¦æ‰§è¡Œä»¥ä¸‹æ“ä½œï¼š

- æ›´æ”¹ nums æ•°ç»„ï¼Œä½¿ nums çš„å‰ k ä¸ªå…ƒç´ åŒ…å«ä¸ç­‰äº val çš„å…ƒç´ ã€‚nums çš„å…¶ä½™å…ƒç´ å’Œ nums çš„å¤§å°å¹¶ä¸é‡è¦ã€‚
- è¿”å› kã€‚

ç¤ºä¾‹ 1ï¼š

```go
è¾“å…¥ï¼šnums = [3,2,2,3], val = 3
è¾“å‡ºï¼š2, nums = [2,2,_,_]
è§£é‡Šï¼šä½ çš„å‡½æ•°å‡½æ•°åº”è¯¥è¿”å› k = 2, å¹¶ä¸” nums ä¸­çš„å‰ä¸¤ä¸ªå…ƒç´ å‡ä¸º 2ã€‚
ä½ åœ¨è¿”å›çš„ k ä¸ªå…ƒç´ ä¹‹å¤–ç•™ä¸‹äº†ä»€ä¹ˆå¹¶ä¸é‡è¦ï¼ˆå› æ­¤å®ƒä»¬å¹¶ä¸è®¡å…¥è¯„æµ‹ï¼‰ã€‚
```

å¦‚æœ fast é‡åˆ°å€¼ä¸º val çš„å…ƒç´ ï¼Œåˆ™ç›´æ¥è·³è¿‡ï¼Œå¦åˆ™å°±èµ‹å€¼ç»™ slow æŒ‡é’ˆï¼Œå¹¶è®© slow å‰è¿›ä¸€æ­¥ã€‚

è¿™å’Œå‰é¢è¯´åˆ°çš„æ•°ç»„å»é‡é—®é¢˜è§£æ³•æ€è·¯æ˜¯å®Œå…¨ä¸€æ ·çš„ï¼Œç›´æ¥çœ‹ä»£ç ï¼š

```go
func removeElement(nums []int, val int) int {
    fast, slow := 0, 0
    for fast < len(nums) {
        if nums[fast] != val {
            nums[slow] = nums[fast]
            slow++
        }
        fast++
    }
    return slow
}
```

æ³¨æ„è¿™é‡Œå’Œæœ‰åºæ•°ç»„å»é‡çš„è§£æ³•æœ‰ä¸€ä¸ªç»†èŠ‚å·®å¼‚ï¼Œæˆ‘ä»¬è¿™é‡Œæ˜¯å…ˆç»™ nums[slow] èµ‹å€¼ç„¶åå†ç»™ slow++ï¼Œè¿™æ ·å¯ä»¥ä¿è¯ nums[0..slow-1] æ˜¯ä¸åŒ…å«å€¼ä¸º val çš„å…ƒç´ çš„ï¼Œæœ€åçš„ç»“æœæ•°ç»„é•¿åº¦å°±æ˜¯ slowã€‚


#### æ»‘åŠ¨çª—å£

æ»‘åŠ¨çª—å£ç®—æ³•æŠ€å·§ä¸»è¦ç”¨æ¥è§£å†³å­æ•°ç»„é—®é¢˜ï¼Œæ¯”å¦‚è®©ä½ å¯»æ‰¾ç¬¦åˆæŸä¸ªæ¡ä»¶çš„æœ€é•¿/æœ€çŸ­å­æ•°ç»„ã€‚

##### æ¨¡æ¿

æ¡†æ¶ä¸­ä¸¤å¤„ `...` è¡¨ç¤ºçš„æ›´æ–°çª—å£æ•°æ®çš„åœ°æ–¹ï¼Œåœ¨å…·ä½“çš„é¢˜ç›®ä¸­ï¼Œä½ éœ€è¦åšçš„å°±æ˜¯å¾€è¿™é‡Œé¢å¡«ä»£ç é€»è¾‘ã€‚è€Œä¸”ï¼Œè¿™ä¸¤ä¸ª `...` å¤„çš„æ“ä½œåˆ†åˆ«æ˜¯æ‰©å¤§å’Œç¼©å°çª—å£çš„æ›´æ–°æ“ä½œï¼Œç­‰ä¼šä½ ä¼šå‘ç°å®ƒä»¬æ“ä½œæ˜¯å®Œå…¨å¯¹ç§°çš„ã€‚


```go
// æ»‘åŠ¨çª—å£ç®—æ³•ä¼ªç æ¡†æ¶
func slidingWindow(s string) {
    // ç”¨åˆé€‚çš„æ•°æ®ç»“æ„è®°å½•çª—å£ä¸­çš„æ•°æ®ï¼Œæ ¹æ®å…·ä½“åœºæ™¯å˜é€š
    // æ¯”å¦‚è¯´ï¼Œæˆ‘æƒ³è®°å½•çª—å£ä¸­å…ƒç´ å‡ºç°çš„æ¬¡æ•°ï¼Œå°±ç”¨ map
    // å¦‚æœæˆ‘æƒ³è®°å½•çª—å£ä¸­çš„å…ƒç´ å’Œï¼Œå°±å¯ä»¥åªç”¨ä¸€ä¸ª int
    var window = ...

    left, right := 0, 0
    for right < len(s) {
        // c æ˜¯å°†ç§»å…¥çª—å£çš„å­—ç¬¦
        c := s[right]
        window[c]++
        // å¢å¤§çª—å£
        right++
        // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
        ...

        // *** debug è¾“å‡ºçš„ä½ç½® ***
        // æ³¨æ„åœ¨æœ€ç»ˆçš„è§£æ³•ä»£ç ä¸­ä¸è¦ print
        // å› ä¸º IO æ“ä½œå¾ˆè€—æ—¶ï¼Œå¯èƒ½å¯¼è‡´è¶…æ—¶
        fmt.Println("window: [",left,", ",right,")")
        // ***********************

        // åˆ¤æ–­å·¦ä¾§çª—å£æ˜¯å¦è¦æ”¶ç¼©
        for left < right && window needs shrink { //replace "window needs shrink" with actual condition
            // d æ˜¯å°†ç§»å‡ºçª—å£çš„å­—ç¬¦
            d := s[left]
            window[d]--
            // ç¼©å°çª—å£
            left++
            // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
            ...
        }
    }
}
```

##### ä¾‹é¢˜

| LeetCode | éš¾åº¦ |
|------|------|
| [438.æ‰¾åˆ°å­—ç¬¦ä¸²ä¸­æ‰€æœ‰å­—æ¯å¼‚ä½è¯](https://leetcode.cn/problems/find-all-anagrams-in-a-string/description/) | ğŸŸ¡ |
| [567.å­—ç¬¦ä¸²çš„æ’åˆ—](https://leetcode.cn/problems/permutation-in-string/description/) | ğŸŸ¡ |
| [3.æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²](https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/) | ğŸŸ¡ |
| [76.æœ€å°è¦†ç›–å­ä¸²](https://leetcode.cn/problems/minimum-window-substring/description/) | ğŸ”´ |

###### 76.æœ€å°è¦†ç›–å­ä¸²

ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸² sã€ä¸€ä¸ªå­—ç¬¦ä¸² tã€‚è¿”å› s ä¸­æ¶µç›– t æ‰€æœ‰å­—ç¬¦çš„æœ€å°å­ä¸²ã€‚å¦‚æœ s ä¸­ä¸å­˜åœ¨æ¶µç›– t æ‰€æœ‰å­—ç¬¦çš„å­ä¸²ï¼Œåˆ™è¿”å›ç©ºå­—ç¬¦ä¸² ""ã€‚

æ³¨æ„ï¼š

- å¯¹äº t ä¸­é‡å¤å­—ç¬¦ï¼Œæˆ‘ä»¬å¯»æ‰¾çš„å­å­—ç¬¦ä¸²ä¸­è¯¥å­—ç¬¦æ•°é‡å¿…é¡»ä¸å°‘äº t ä¸­è¯¥å­—ç¬¦æ•°é‡ã€‚
- å¦‚æœ s ä¸­å­˜åœ¨è¿™æ ·çš„å­ä¸²ï¼Œæˆ‘ä»¬ä¿è¯å®ƒæ˜¯å”¯ä¸€çš„ç­”æ¡ˆã€‚
 
ç¤ºä¾‹ 1ï¼š

```go
è¾“å…¥ï¼šs = "ADOBECODEBANC", t = "ABC"
è¾“å‡ºï¼š"BANC"
è§£é‡Šï¼šæœ€å°è¦†ç›–å­ä¸² "BANC" åŒ…å«æ¥è‡ªå­—ç¬¦ä¸² t çš„ 'A'ã€'B' å’Œ 'C'ã€‚
```


```go
func minWindow(s string, t string) string {
    // need è®°å½•ç›®æ ‡å­—ç¬¦ä¸²ä¸­æ¯ä¸ªå­—ç¬¦å‡ºç°çš„æ¬¡æ•°
    // window è®°å½•æ»‘åŠ¨çª—å£ä¸­ç›¸åº”å­—ç¬¦å‡ºç°çš„æ¬¡æ•°
    need, window := make(map[byte]int), make(map[byte]int)
    for i := range t {
        need[t[i]]++
    }

    left, right := 0, 0
    valid := 0
    // è®°å½•æœ€å°è¦†ç›–å­ä¸²çš„èµ·å§‹ç´¢å¼•åŠé•¿åº¦
    start, length := 0, math.MaxInt32
    for right < len(s) {
        // c æ˜¯å°†ç§»å…¥çª—å£çš„å­—ç¬¦
        c := s[right]
        // æ‰©å¤§çª—å£
        right++
        // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
        if _, ok := need[c]; ok {
            window[c]++
            if window[c] == need[c] {
                valid++
            }
        }

        // åˆ¤æ–­å·¦ä¾§çª—å£æ˜¯å¦è¦æ”¶ç¼©
        for valid == len(need) {
            // åœ¨è¿™é‡Œæ›´æ–°æœ€å°è¦†ç›–å­ä¸²
            if right - left < length {
                start = left
                length = right - left
            }
            // d æ˜¯å°†ç§»å‡ºçª—å£çš„å­—ç¬¦
            d := s[left]
            // ç¼©å°çª—å£
            left++
            // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
            if _, ok := need[d]; ok {
                if window[d] == need[d] {
                    valid--
                }
                window[d]--
            }
        }
    }
    // è¿”å›æœ€å°è¦†ç›–å­ä¸²
    if length == math.MaxInt32 {
        return ""
    }
    return s[start : start+length]
}
```

###### 567.å­—ç¬¦ä¸²çš„æ’åˆ—

ç»™ä½ ä¸¤ä¸ªå­—ç¬¦ä¸² s1 å’Œ s2 ï¼Œå†™ä¸€ä¸ªå‡½æ•°æ¥åˆ¤æ–­ s2 æ˜¯å¦åŒ…å« s1 çš„æ’åˆ—ã€‚å¦‚æœæ˜¯ï¼Œè¿”å› trueï¼›å¦åˆ™ï¼Œè¿”å› falseã€‚

æ¢å¥è¯è¯´ï¼Œs1 çš„æ’åˆ—ä¹‹ä¸€æ˜¯ s2 çš„å­ä¸² ã€‚

ç¤ºä¾‹ 1ï¼š

```go
è¾“å…¥ï¼šs1 = "ab" s2 = "eidbaooo"
è¾“å‡ºï¼štrue
è§£é‡Šï¼šs2 åŒ…å« s1 çš„æ’åˆ—ä¹‹ä¸€ ("ba").
```

ç¤ºä¾‹ 2ï¼š

```go
è¾“å…¥ï¼šs1= "ab" s2 = "eidboaoo"
è¾“å‡ºï¼šfalse
```

æç¤ºï¼š

- 1 <= s1.length, s2.length <= 104
- s1 å’Œ s2 ä»…åŒ…å«å°å†™å­—æ¯

è¿™ç§é¢˜ç›®ï¼Œæ˜¯æ˜æ˜¾çš„æ»‘åŠ¨çª—å£ç®—æ³•ï¼Œç›¸å½“ç»™ä½ ä¸€ä¸ª s å’Œä¸€ä¸ª tï¼Œè¯·é—®ä½  s ä¸­æ˜¯å¦å­˜åœ¨ä¸€ä¸ªå­ä¸²ï¼ŒåŒ…å« t ä¸­æ‰€æœ‰å­—ç¬¦ä¸”ä¸åŒ…å«å…¶ä»–å­—ç¬¦ã€‚

```go
// åˆ¤æ–­ s ä¸­æ˜¯å¦å­˜åœ¨ t çš„æ’åˆ—
func checkInclusion(t string, s string) bool {
	need := make(map[byte]int)
	window := make(map[byte]int)

	for c := range t {
		need[t[c]]++
	}

	left, right := 0, 0
	valid := 0
	for right < len(s) {
		c := s[right]
		right++
        // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
		if _, ok := need[c]; ok {
			window[c]++
			if window[c] == need[c] {
				valid++
			}
		}

        // åˆ¤æ–­å·¦ä¾§çª—å£æ˜¯å¦è¦æ”¶ç¼©
        // çª—å£é•¿åº¦ç­‰äº t æ—¶ï¼Œå·¦ä¾§æŒ‡é’ˆ left ä¼šæ”¶ç¼©çª—å£ï¼Œä¿è¯çª—å£ä¸­æ²¡æœ‰å¤šä½™å­—ç¬¦
		for right-left == len(t) {
            // åœ¨è¿™é‡Œåˆ¤æ–­æ˜¯å¦æ‰¾åˆ°äº†åˆæ³•çš„å­ä¸²
			if valid == len(need) {
				return true
			}
			d := s[left]
			left++
            // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
			if _, ok := need[d]; ok {
				if window[d] == need[d] {
					valid--
				}
				window[d]--
			}
		}
	}
    // æœªæ‰¾åˆ°ç¬¦åˆæ¡ä»¶çš„å­ä¸²
	return false
}
```

###### 438.æ‰¾åˆ°å­—ç¬¦ä¸²ä¸­æ‰€æœ‰å­—æ¯å¼‚ä½è¯

ç»™å®šä¸¤ä¸ªå­—ç¬¦ä¸² s å’Œ pï¼Œæ‰¾åˆ° s ä¸­æ‰€æœ‰ p çš„å¼‚ä½è¯çš„å­ä¸²ï¼Œè¿”å›è¿™äº›å­ä¸²çš„èµ·å§‹ç´¢å¼•ã€‚ä¸è€ƒè™‘ç­”æ¡ˆè¾“å‡ºçš„é¡ºåºã€‚

ç¤ºä¾‹ 1:

```go
è¾“å…¥: s = "cbaebabacd", p = "abc"
è¾“å‡º: [0,6]
è§£é‡Š:
èµ·å§‹ç´¢å¼•ç­‰äº 0 çš„å­ä¸²æ˜¯ "cba", å®ƒæ˜¯ "abc" çš„å¼‚ä½è¯ã€‚
èµ·å§‹ç´¢å¼•ç­‰äº 6 çš„å­ä¸²æ˜¯ "bac", å®ƒæ˜¯ "abc" çš„å¼‚ä½è¯ã€‚
```

è¿™ä¸ªæ‰€è°“çš„å­—æ¯å¼‚ä½è¯ï¼Œä¸å°±æ˜¯æ’åˆ—å—ï¼Œæä¸ªé«˜ç«¯çš„è¯´æ³•å°±èƒ½ç³Šå¼„äººäº†å—ï¼Ÿç›¸å½“äºï¼Œè¾“å…¥ä¸€ä¸ªä¸² sï¼Œä¸€ä¸ªä¸² pï¼Œæ‰¾åˆ° s ä¸­æ‰€æœ‰ p çš„æ’åˆ—ï¼Œè¿”å›å®ƒä»¬çš„èµ·å§‹ç´¢å¼•ã€‚

```go
func findAnagrams(s string, p string) []int {
    // è®°å½•ç»“æœ
	ans := []int{}
	need := make(map[byte]int)
	window := make(map[byte]int)

	for i := range p {
		need[p[i]]++
	}

	left, right := 0, 0
	valid := 0

	for right < len(s) {
		c := s[right]
		right++
        // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
		if _, ok := need[c]; ok {
			window[c]++
			if window[c] == need[c] {
				valid++
			}
		}

        // åˆ¤æ–­å·¦ä¾§çª—å£æ˜¯å¦è¦æ”¶ç¼©
        // ä¿è¯çª—å£é•¿åº¦å§‹ç»ˆå’Œ p çš„é•¿åº¦ä¸€è‡´
		for right-left == len(p) {
            // å½“çª—å£ç¬¦åˆæ¡ä»¶æ—¶ï¼ŒæŠŠèµ·å§‹ç´¢å¼•åŠ å…¥ res
			if valid == len(need) {
				ans = append(ans, left)
			}

			d := s[left]
			left++
            // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
			if _, ok := need[d]; ok {
				if window[d] == need[d] {
					valid--
				}
				window[d]--
			}
		}
	}
	return ans
}
```

###### 4.æœ€é•¿æ— é‡å¤å­ä¸²

ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸² sï¼Œè¯·ä½ æ‰¾å‡ºå…¶ä¸­ä¸å«æœ‰é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²çš„é•¿åº¦ã€‚

ç¤ºä¾‹ 1:

```go
è¾“å…¥: s = "abcabcbb"
è¾“å‡º: 3 
è§£é‡Š: å› ä¸ºæ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²æ˜¯ "abc"ï¼Œæ‰€ä»¥å…¶é•¿åº¦ä¸º 3ã€‚
```

è¿™ä¸ªé¢˜ç»ˆäºæœ‰äº†ç‚¹æ–°æ„ï¼Œä¸æ˜¯ä¸€å¥—æ¡†æ¶å°±å‡ºç­”æ¡ˆï¼Œä¸è¿‡åè€Œæ›´ç®€å•äº†ï¼Œç¨å¾®æ”¹ä¸€æ”¹æ¡†æ¶å°±è¡Œäº†ï¼š
- è¿™å°±æ˜¯å˜ç®€å•äº†ï¼Œè¿ need å’Œ valid éƒ½ä¸éœ€è¦ï¼Œè€Œä¸”æ›´æ–°çª—å£å†…æ•°æ®ä¹Ÿåªéœ€è¦ç®€å•çš„æ›´æ–°è®¡æ•°å™¨ window å³å¯ã€‚
- å½“ window[c] å€¼å¤§äº 1 æ—¶ï¼Œè¯´æ˜çª—å£ä¸­å­˜åœ¨é‡å¤å­—ç¬¦ï¼Œä¸ç¬¦åˆæ¡ä»¶ï¼Œå°±è¯¥ç§»åŠ¨ left ç¼©å°çª—å£äº†å˜›ã€‚

```go
func lengthOfLongestSubstring(s string) int {
	window := make(map[byte]int)
	left, right := 0, 0
	// è®°å½•ç»“æœ
	res := 0

	for right < len(s) {
		c := s[right]
		right++
		// è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
		window[c] = window[c] + 1

		// åˆ¤æ–­å·¦ä¾§çª—å£æ˜¯å¦è¦æ”¶ç¼©
		for window[c] > 1 {
			d := s[left]
			left++

			// è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–°
			window[d] = window[d] - 1
		}

		// åœ¨è¿™é‡Œæ›´æ–°ç­”æ¡ˆ
		if res < right-left {
			res = right - left
		}
	}
	return res
}
```

#### å·¦å³æŒ‡é’ˆ

##### äºŒåˆ†æŸ¥æ‰¾

- 1.åˆ†æäºŒåˆ†æŸ¥æ‰¾ä»£ç æ—¶ï¼Œä¸è¦å‡ºç° elseï¼Œå…¨éƒ¨å±•å¼€æˆ else if æ–¹ä¾¿ç†è§£ã€‚æŠŠé€»è¾‘å†™å¯¹ä¹‹åå†åˆå¹¶åˆ†æ”¯ï¼Œæå‡è¿è¡Œæ•ˆç‡ã€‚
- 2.æ³¨æ„ã€Œæœç´¢åŒºé—´ã€å’Œ while çš„ç»ˆæ­¢æ¡ä»¶ï¼Œå¦‚æœå­˜åœ¨æ¼æ‰çš„å…ƒç´ ï¼Œè®°å¾—åœ¨æœ€åæ£€æŸ¥ã€‚
- 3.å¦‚æœå°†ã€Œæœç´¢åŒºé—´ã€å…¨éƒ½ç»Ÿä¸€æˆä¸¤ç«¯éƒ½é—­ï¼Œå¥½è®°ï¼Œåªè¦ç¨æ”¹ nums[mid] == target æ¡ä»¶å¤„çš„ä»£ç å’Œè¿”å›çš„é€»è¾‘å³å¯ï¼Œæ¨èæ‹¿å°æœ¬æœ¬è®°ä¸‹ï¼Œä½œä¸ºäºŒåˆ†æœç´¢æ¨¡æ¿ã€‚

```go
// åŸºæœ¬äºŒåˆ†æŸ¥æ‰¾
func binarySearch(nums []int, target int) int {
    left, right := 0, len(nums)-1
    for left <= right {
        mid := left + (right - left) / 2
        if nums[mid] < target {
            left = mid + 1
        } else if nums[mid] > target {
            right = mid - 1
        } else if nums[mid] == target {
            // ç›´æ¥è¿”å›
            return mid
        }
    }
    // ç›´æ¥è¿”å›
    return -1
}

// å¯»æ‰¾å·¦è¾¹ç•Œçš„äºŒåˆ†æŸ¥æ‰¾
func leftBound(nums []int, target int) int {
    left, right := 0, len(nums)-1
    for left <= right {
        mid := left + (right - left) / 2
        if nums[mid] < target {
            left = mid + 1
        } else if nums[mid] > target {
            right = mid - 1
        } else if nums[mid] == target {
            // åˆ«è¿”å›ï¼Œé”å®šå·¦ä¾§è¾¹ç•Œ
            right = mid - 1
        }
    }
    // åˆ¤æ–­ target æ˜¯å¦å­˜åœ¨äº nums ä¸­
    if left < 0 || left >= len(nums) {
        return -1
    }
    // åˆ¤æ–­ä¸€ä¸‹ nums[left] æ˜¯ä¸æ˜¯ target
    if nums[left] == target {
        return left
    }
    return -1
}

// å¯»æ‰¾å³è¾¹ç•Œçš„äºŒåˆ†æŸ¥æ‰¾
func rightBound(nums []int, target int) int {
    left, right := 0, len(nums)-1
    for left <= right {
        mid := left + (right - left) / 2
        if nums[mid] < target {
            left = mid + 1
        } else if nums[mid] > target {
            right = mid - 1
        } else if nums[mid] == target {
            // åˆ«è¿”å›ï¼Œé”å®šå³ä¾§è¾¹ç•Œ
            left = mid + 1
        }
    }
    
    if right < 0 || right >= len(nums) {
        return -1
    }
    if nums[right] == target {
        return right
    }
    return -1
}
```

##### n æ•°ä¹‹å’Œ

æ€»ç»“æ¥è¯´ï¼Œè¿™ç±» nSum é—®é¢˜å°±æ˜¯ç»™ä½ è¾“å…¥ä¸€ä¸ªæ•°ç»„ nums å’Œä¸€ä¸ªç›®æ ‡å’Œ targetï¼Œè®©ä½ ä» nums é€‰æ‹© n ä¸ªæ•°ï¼Œä½¿å¾—è¿™äº›æ•°å­—ä¹‹å’Œä¸º targetã€‚

| LeetCode  | éš¾åº¦ |
|---------------------------------------------------|------|
|[1.ä¸¤æ•°ä¹‹å’Œ](https://leetcode.cn/problems/two-sum)            | ğŸŸ¢   |
|[15.ä¸‰æ•°ä¹‹å’Œ](https://leetcode.cn/problems/3sum)               | ğŸŸ    |
|[18.å››æ•°ä¹‹å’Œ](https://leetcode.cn/problems/4sum)               | ğŸŸ    |

###### 1.ä¸¤æ•°ä¹‹å’Œ

å‡è®¾è¾“å…¥ä¸€ä¸ªæ•°ç»„ nums å’Œä¸€ä¸ªç›®æ ‡å’Œ targetï¼Œè¯·ä½ è¿”å› nums ä¸­æ‰€æœ‰èƒ½å¤Ÿå‡‘å‡º target çš„ä¸¤ä¸ªå…ƒç´ çš„å€¼ï¼Œå…¶ä¸­ä¸èƒ½å‡ºç°é‡å¤ï¼Œæ¯”å¦‚è¯´è¾“å…¥ä¸º nums = [1,3,1,2,2,3], target = 4ï¼Œé‚£ä¹ˆç®—æ³•è¿”å›çš„ç»“æœå°±æ˜¯ï¼š[[1,3],[2,2]]ï¼ˆæ³¨æ„ï¼Œæˆ‘è¦æ±‚è¿”å›å…ƒç´ ï¼Œè€Œä¸æ˜¯ç´¢å¼•ï¼‰ã€‚æ¯”å¦‚ [1,3] å’Œ [3,1] å°±ç®—é‡å¤ï¼Œåªèƒ½ç®—ä¸€æ¬¡ã€‚

æˆ‘ä»¬å¯ä»¥å…ˆå¯¹ nums æ’åºï¼Œç„¶ååˆ©ç”¨å·¦å³åŒæŒ‡é’ˆæŠ€å·§ï¼Œä»ä¸¤ç«¯ç›¸å‘è€Œè¡Œã€‚å½“ç»™ res åŠ å…¥ä¸€æ¬¡ç»“æœåï¼Œlo å’Œ hi ä¸ä»…åº”è¯¥ç›¸å‘è€Œè¡Œï¼Œè€Œä¸”åº”è¯¥è·³è¿‡æ‰€æœ‰é‡å¤çš„å…ƒç´ ã€‚


![](https://chengzw258.oss-cn-beijing.aliyuncs.com/Article/202412251104761.png)

```go
func twoSum(nums []int, target int) [][]int {
    // nums æ•°ç»„å¿…é¡»æœ‰åº
    sort.Ints(nums)
    var lo, hi int = 0, len(nums) - 1
    var res [][]int
    for lo < hi {
        sum := nums[lo] + nums[hi]
        // è®°å½•ç´¢å¼• lo å’Œ hi æœ€åˆå¯¹åº”çš„å€¼
        left, right := nums[lo], nums[hi]
        if sum < target {
            lo++
        } else if sum > target {
            hi--
        } else {
            res = append(res, []int{left, right})
            
            // è·³è¿‡æ‰€æœ‰é‡å¤çš„å…ƒç´ 
            for lo < hi && nums[lo] == left {
                lo++
            }
            for lo < hi && nums[hi] == right {
                hi--
            }
        }
    }
    return res
}
```

æ³¨æ„ LeetCode çš„ [1.ä¸¤æ•°ä¹‹å’Œ](https://leetcode.cn/problems/two-sum) ä¸€é¢˜ä¸­ï¼Œè¦æ±‚è¿”å›çš„æ˜¯æ•°ç»„ä¸‹æ ‡ï¼Œå› æ­¤ä¸èƒ½å¯¹åŸæ•°ç»„è¿›è¡Œæ’åºï¼Œéœ€è¦ä½¿ç”¨å“ˆå¸Œè¡¨çš„åšæ³•ï¼Œè§£æ³•å‚è€ƒï¼š[hot100#ä¸¤æ•°ä¹‹å’Œ](01-hot100#ä¸¤æ•°ä¹‹å’Œ)ã€‚

###### 15.ä¸‰æ•°ä¹‹å’Œ

ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ numsï¼Œåˆ¤æ–­æ˜¯å¦å­˜åœ¨ä¸‰å…ƒç»„ [nums[i], nums[j], nums[k]] æ»¡è¶³ i != jã€i != k ä¸” j != kï¼ŒåŒæ—¶è¿˜æ»¡è¶³ nums[i] + nums[j] + nums[k] == 0ã€‚è¯·ä½ è¿”å›æ‰€æœ‰å’Œä¸º 0 ä¸”ä¸é‡å¤çš„ä¸‰å…ƒç»„ã€‚

æ³¨æ„ï¼šç­”æ¡ˆä¸­ä¸å¯ä»¥åŒ…å«é‡å¤çš„ä¸‰å…ƒç»„ã€‚

ç¤ºä¾‹ 1ï¼š

```go
è¾“å…¥ï¼šnums = [-1,0,1,2,-1,-4]
è¾“å‡ºï¼š[[-1,-1,2],[-1,0,1]]
è§£é‡Šï¼š
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 ã€‚
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 ã€‚
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 ã€‚
ä¸åŒçš„ä¸‰å…ƒç»„æ˜¯ [-1,0,1] å’Œ [-1,-1,2] ã€‚
æ³¨æ„ï¼Œè¾“å‡ºçš„é¡ºåºå’Œä¸‰å…ƒç»„çš„é¡ºåºå¹¶ä¸é‡è¦ã€‚
```


ç©·ä¸¾ç¬¬ä¸€ä¸ªæ•°ï¼Œå¹¶ä¿è¯ä¸€ä¸ªæ•°ä¸é‡å¤ï¼Œç„¶åå¤ç”¨ twoSum å‡½æ•°ä¼šä¿è¯åé¢ä¸¤ä¸ªæ•°ä¸é‡å¤ã€‚å°† twoSum è¿”å›çš„ç»“æœåŠ ä¸Šç¬¬ä¸€ä¸ªæ•°æ”¾åˆ°ç»“æœåˆ—è¡¨ä¸­ã€‚ 

```go
// è®¡ç®—æ•°ç»„ nums ä¸­æ‰€æœ‰å’Œä¸º target çš„ä¸‰å…ƒç»„
func threeSum(nums []int) [][]int {
    // æ•°ç»„å¾—æ’ä¸ªåº 
	sort.Ints(nums)
	var res [][]int
	n := len(nums)
    // ç©·ä¸¾ threeSum çš„ç¬¬ä¸€ä¸ªæ•°
	for i := 0; i < n; i++ {
        // è·³è¿‡ç¬¬ä¸€ä¸ªæ•°å­—é‡å¤çš„æƒ…å†µï¼Œå¦åˆ™ä¼šå‡ºç°é‡å¤ç»“æœ
        if i > 0 && nums[i] == nums[i-1] {
            continue
        }

        // å¯¹ target - nums[i] è®¡ç®— twoSum
		tuples := twoSum(nums, i+1, 0-nums[i])
        // å¦‚æœå­˜åœ¨æ»¡è¶³æ¡ä»¶çš„äºŒå…ƒç»„ï¼Œå†åŠ ä¸Š nums[i] å°±æ˜¯ç»“æœä¸‰å…ƒç»„
		for _, tuple := range tuples {
			tuple = append(tuple, nums[i])
			res = append(res, tuple)
		}
	}
	return res
}

// ä» nums[start] å¼€å§‹ï¼Œè®¡ç®—æœ‰åºæ•°ç»„ nums ä¸­æ‰€æœ‰å’Œä¸º target çš„äºŒå…ƒç»„
func twoSum(nums []int, start int, target int) [][]int {
	var res [][]int
    // å·¦æŒ‡é’ˆæ”¹ä¸ºä» start å¼€å§‹ï¼Œå…¶ä»–ä¸å˜
	lo, hi := start, len(nums)-1
	for lo < hi {
		sum := nums[lo] + nums[hi]
		left, right := nums[lo], nums[hi]
		if sum < target {
			lo++
		} else if sum > target {
			hi--
		} else {
			res = append(res, []int{nums[lo], nums[hi]})

			for lo < hi && nums[lo] == left {
				lo++
			}
			for lo < hi && nums[hi] == right {
				hi--
			}
		}
	}
	return res
}
```

###### 18.å››æ•°ä¹‹å’Œ

ç»™ä½ ä¸€ä¸ªç”± n ä¸ªæ•´æ•°ç»„æˆçš„æ•°ç»„ numsï¼Œå’Œä¸€ä¸ªç›®æ ‡å€¼ targetã€‚è¯·ä½ æ‰¾å‡ºå¹¶è¿”å›æ»¡è¶³ä¸‹è¿°å…¨éƒ¨æ¡ä»¶ä¸”ä¸é‡å¤çš„å››å…ƒç»„ [nums[a], nums[b], nums[c], nums[d]]ï¼ˆè‹¥ä¸¤ä¸ªå››å…ƒç»„å…ƒç´ ä¸€ä¸€å¯¹åº”ï¼Œåˆ™è®¤ä¸ºä¸¤ä¸ªå››å…ƒç»„é‡å¤ï¼‰ï¼š

- 0 <= a, b, c, d < n
- aã€bã€c å’Œ d äº’ä¸ç›¸åŒ
- nums[a] + nums[b] + nums[c] + nums[d] == target

ä½ å¯ä»¥æŒ‰ä»»æ„é¡ºåºè¿”å›ç­”æ¡ˆã€‚

ç¤ºä¾‹ 1ï¼š

```go
è¾“å…¥ï¼šnums = [1,0,-1,0,-2,2], target = 0
è¾“å‡ºï¼š[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
```

fourSum å®Œå…¨å°±å¯ä»¥ç”¨ç›¸åŒçš„æ€è·¯ï¼šç©·ä¸¾ç¬¬ä¸€ä¸ªæ•°å­—ï¼Œç„¶åè°ƒç”¨ threeSum å‡½æ•°è®¡ç®—å‰©ä¸‹ä¸‰ä¸ªæ•°ï¼Œæœ€åç»„åˆå‡ºå’Œä¸º target çš„å››å…ƒç»„ã€‚

æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸€ä¸ªç»Ÿä¸€çš„ nSum é€’å½’å‡½æ•°æ¥è§£å†³ï¼Œè¿™æ ·å¦‚æœæœ‰ 100Sum çš„é—®é¢˜ä¹Ÿä¸€æ ·å¯ä»¥å¤„ç†ã€‚

```go
func fourSum(nums []int, target int) [][]int {
    sort.Ints(nums)
    return nSum(nums, 4, 0, target)
}

// æ³¨æ„ï¼šè°ƒç”¨è¿™ä¸ªå‡½æ•°ä¹‹å‰ä¸€å®šè¦å…ˆç»™ nums æ’åº
// n å¡«å†™æƒ³æ±‚çš„æ˜¯å‡ æ•°ä¹‹å’Œï¼Œstart ä»å“ªä¸ªç´¢å¼•å¼€å§‹è®¡ç®—ï¼ˆä¸€èˆ¬å¡« 0ï¼‰ï¼Œtarget å¡«æƒ³å‡‘å‡ºçš„ç›®æ ‡å’Œ
func nSum(nums []int, n int, start int, target int) [][]int {
    sz := len(nums)
    res := [][]int{}
    // è‡³å°‘æ˜¯ 2Sumï¼Œä¸”æ•°ç»„å¤§å°ä¸åº”è¯¥å°äº n
    if n < 2 || sz < n {
        return res
    }
    // 2Sum æ˜¯ base case
    if n == 2 {
        lo, hi := start, sz-1
        for lo < hi {
            sum := nums[lo] + nums[hi]
            left, right := nums[lo], nums[hi]
            if sum < target {
                for lo < hi && nums[lo] == left {
                    lo++
                }
            } else if sum > target {
                for lo < hi && nums[hi] == right {
                    hi--
                }
            } else {
                res = append(res, []int{left, right})
                for lo < hi && nums[lo] == left {
                    lo++
                }
                for lo < hi && nums[hi] == right {
                    hi--
                }
            }
        }
    } else {
        // n > 2 æ—¶ï¼Œé€’å½’è®¡ç®— (n-1)Sum çš„ç»“æœ
        for i := start; i < sz; i++ {
            // è·³è¿‡é‡å¤å€¼
            if i > start && nums[i] == nums[i-1] {
                continue
            }
            subs := nSum(nums, n-1, i+1, target-nums[i])
            for _, sub := range subs {
                // (n-1)Sum åŠ ä¸Š nums[i] å°±æ˜¯ nSum
                res = append(res, append(sub, nums[i]))
            }
        }
    }
    return res
}
```

##### åè½¬æ•°ç»„

###### 344.åè½¬å­—ç¬¦ä¸²

ç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œå…¶ä½œç”¨æ˜¯å°†è¾“å…¥çš„å­—ç¬¦ä¸²åè½¬è¿‡æ¥ã€‚è¾“å…¥å­—ç¬¦ä¸²ä»¥å­—ç¬¦æ•°ç»„ s çš„å½¢å¼ç»™å‡ºã€‚

ä¸è¦ç»™å¦å¤–çš„æ•°ç»„åˆ†é…é¢å¤–çš„ç©ºé—´ï¼Œä½ å¿…é¡»åŸåœ°ä¿®æ”¹è¾“å…¥æ•°ç»„ã€ä½¿ç”¨ O(1) çš„é¢å¤–ç©ºé—´è§£å†³è¿™ä¸€é—®é¢˜ã€‚

ç¤ºä¾‹ 1ï¼š

```go
è¾“å…¥ï¼šs = ["h","e","l","l","o"]
è¾“å‡ºï¼š["o","l","l","e","h"]
```

```go
func reverseString(s []byte)  {
    // ä¸€å·¦ä¸€å³ä¸¤ä¸ªæŒ‡é’ˆç›¸å‘è€Œè¡Œ
    left, right := 0, len(s)-1
    for left < right {
        // äº¤æ¢ s[left] å’Œ s[right]
        s[left], s[right] = s[right], s[left]
        left++
        right--
    }
}
```

##### å›æ–‡ä¸²åˆ¤æ–­

å›æ–‡ä¸²å°±æ˜¯æ­£ç€è¯»å’Œåç€è¯»éƒ½ä¸€æ ·çš„å­—ç¬¦ä¸²ã€‚æ¯”å¦‚è¯´å­—ç¬¦ä¸² aba å’Œ abba éƒ½æ˜¯å›æ–‡ä¸²ï¼Œå› ä¸ºå®ƒä»¬å¯¹ç§°ï¼Œåè¿‡æ¥è¿˜æ˜¯å’Œæœ¬èº«ä¸€æ ·ï¼›åä¹‹ï¼Œå­—ç¬¦ä¸² abac å°±ä¸æ˜¯å›æ–‡ä¸²ã€‚

ç°åœ¨ä½ åº”è¯¥èƒ½æ„Ÿè§‰åˆ°å›æ–‡ä¸²é—®é¢˜å’Œå·¦å³æŒ‡é’ˆè‚¯å®šæœ‰å¯†åˆ‡çš„è”ç³»ï¼Œæ¯”å¦‚è®©ä½ åˆ¤æ–­ä¸€ä¸ªå­—ç¬¦ä¸²æ˜¯ä¸æ˜¯å›æ–‡ä¸²ï¼Œä½ å¯ä»¥å†™å‡ºä¸‹é¢è¿™æ®µä»£ç ï¼š

```go
func isPalindrome(s string) bool {
    // ä¸€å·¦ä¸€å³ä¸¤ä¸ªæŒ‡é’ˆç›¸å‘è€Œè¡Œ
    left, right := 0, len(s) - 1
    for left < right {
        if s[left] != s[right] {
            return false
        }
        left++
        right--
    }
    return true
}
```

###### 5.æœ€é•¿å›æ–‡å­ä¸²

ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸² sï¼Œæ‰¾åˆ° s ä¸­æœ€é•¿çš„å›æ–‡å­ä¸²ã€‚

ç¤ºä¾‹ 1ï¼š

```go
è¾“å…¥ï¼šs = "babad"
è¾“å‡ºï¼š"bab"
è§£é‡Šï¼š"aba" åŒæ ·æ˜¯ç¬¦åˆé¢˜æ„çš„ç­”æ¡ˆã€‚
```

éå† sï¼Œåˆ†åˆ«æ‰¾åˆ°ä»¥ i ä¸ºä¸­å¿ƒçš„å¥‡æ•°å’Œå¶æ•°çš„æœ€é•¿å›æ–‡å­ä¸²ï¼Œæœ€åè¿”å›æœ€é•¿çš„å›æ–‡å­ä¸²ã€‚

```go
func longestPalindrome(s string) string {
    var res string
    for i := 0; i < len(s); i++ {
        // ä»¥ s[i] ä¸ºä¸­å¿ƒçš„æœ€é•¿å›æ–‡å­ä¸²
        s1 := palindrome(s, i, i)
        // ä»¥ s[i] å’Œ s[i+1] ä¸ºä¸­å¿ƒçš„æœ€é•¿å›æ–‡å­ä¸²
        s2 := palindrome(s, i, i+1)
        // res = longest(res, s1, s2)
        if len(res) < len(s1) {
            res = s1
        }
        if len(res) < len(s2) {
            res = s2
        }
    }
    return res
}
// åœ¨ s ä¸­å¯»æ‰¾ä»¥ s[l] å’Œ s[r] ä¸ºä¸­å¿ƒçš„æœ€é•¿å›æ–‡ä¸²
func palindrome(s string, l int, r int) string {
    // é˜²æ­¢ç´¢å¼•è¶Šç•Œ
    for l >= 0 && r < len(s) && s[l] == s[r] {
        // åŒæŒ‡é’ˆï¼Œå‘ä¸¤è¾¹å±•å¼€
        l--
        r++
    }
    // è¿”å›ä»¥ s[l] å’Œ s[r] ä¸ºä¸­å¿ƒçš„æœ€é•¿å›æ–‡ä¸²
    return s[l+1 : r]
}
```

### äºŒç»´æ•°ç»„éå†

#### é¡º/é€†æ—¶é’ˆæ—‹è½¬çŸ©é˜µ

æˆ‘ä»¬å¯ä»¥å…ˆå°† n x n çŸ©é˜µ matrix æŒ‰ç…§å·¦ä¸Šåˆ°å³ä¸‹çš„å¯¹è§’çº¿è¿›è¡Œé•œåƒå¯¹ç§°ï¼š

![](https://chengzw258.oss-cn-beijing.aliyuncs.com/Article/202412251533896.png)

ç„¶åå†å¯¹çŸ©é˜µçš„æ¯ä¸€è¡Œè¿›è¡Œåè½¬ï¼š

![](https://chengzw258.oss-cn-beijing.aliyuncs.com/Article/202412251533432.png)

å‘ç°ç»“æœå°±æ˜¯ matrix é¡ºæ—¶é’ˆæ—‹è½¬ 90 åº¦çš„ç»“æœï¼š

![](https://chengzw258.oss-cn-beijing.aliyuncs.com/Article/202412251533794.png)

```go
var rotate = func(matrix [][]int) {
    // å°†äºŒç»´çŸ©é˜µåŸåœ°é¡ºæ—¶é’ˆæ—‹è½¬ 90 åº¦
    n := len(matrix)
    // å…ˆæ²¿å¯¹è§’çº¿é•œåƒå¯¹ç§°äºŒç»´çŸ©é˜µ
    for i := 0; i < n; i++ {
        for j := i; j < n; j++ {
            // swap(matrix[i][j], matrix[j][i]);
            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
        }
    }
    // ç„¶ååè½¬äºŒç»´çŸ©é˜µçš„æ¯ä¸€è¡Œ
    for _, row := range matrix {
        reverse(row)
    }
}

// ç¿»è½¬ä¸€ç»´æ•°ç»„
func reverse(arr []int) {
    i, j := 0, len(arr) - 1
    for j > i {
        // swap(arr[i], arr[j]);
        arr[i], arr[j] = arr[j], arr[i]
        i++
        j--
    }
}
```

å¦‚ä½•å°†çŸ©é˜µé€†æ—¶é’ˆæ—‹è½¬ 90 åº¦å‘¢ï¼Ÿæ€è·¯æ˜¯ç±»ä¼¼çš„ï¼Œåªè¦é€šè¿‡å¦ä¸€æ¡å¯¹è§’çº¿é•œåƒå¯¹ç§°çŸ©é˜µï¼Œç„¶åå†åè½¬æ¯ä¸€è¡Œï¼Œå°±å¾—åˆ°äº†é€†æ—¶é’ˆæ—‹è½¬çŸ©é˜µçš„ç»“æœï¼š

![](https://chengzw258.oss-cn-beijing.aliyuncs.com/Article/202412251537245.png)

```go
// å°†äºŒç»´çŸ©é˜µåŸåœ°é€†æ—¶é’ˆæ—‹è½¬ 90 åº¦
func rotate2(matrix [][]int) {
    n := len(matrix)
    // æ²¿å·¦ä¸‹åˆ°å³ä¸Šçš„å¯¹è§’çº¿é•œåƒå¯¹ç§°äºŒç»´çŸ©é˜µ
    for i := 0; i < n; i++ {
        for j := 0; j < n - i; j++ {
            // swap(matrix[i][j], matrix[n-j-1][n-i-1])
            temp := matrix[i][j]
            matrix[i][j] = matrix[n - j - 1][n - i - 1]
            matrix[n - j - 1][n - i - 1] = temp
        }
    }

    // ç„¶ååè½¬äºŒç»´çŸ©é˜µçš„æ¯ä¸€è¡Œ
    for _, row := range matrix {
        reverse(row)
    }
}

func reverse(arr []int) {
    // è§ä¸Šæ–‡
}
```

#### çŸ©é˜µçš„èºæ—‹éå†

##### 54.èºæ—‹çŸ©é˜µ

è§£é¢˜çš„æ ¸å¿ƒæ€è·¯æ˜¯æŒ‰ç…§å³ã€ä¸‹ã€å·¦ã€ä¸Šçš„é¡ºåºéå†æ•°ç»„ï¼Œå¹¶ä½¿ç”¨å››ä¸ªå˜é‡åœˆå®šæœªéå†å…ƒç´ çš„è¾¹ç•Œï¼š

![](https://chengzw258.oss-cn-beijing.aliyuncs.com/Article/202412251540244.png)

```go
func spiralOrder(matrix [][]int) []int {
    var res []int
    m := len(matrix)
    n := len(matrix[0])
    upper_bound := 0
    lower_bound := m - 1
    left_bound := 0
    right_bound := n - 1
    // res.size() == m * n åˆ™éå†å®Œæ•´ä¸ªæ•°ç»„
    for len(res) < m*n {
        if upper_bound <= lower_bound {
            // åœ¨é¡¶éƒ¨ä»å·¦å‘å³éå†
            for j := left_bound; j <= right_bound; j++ {
                res = append(res, matrix[upper_bound][j])
            }
            // ä¸Šè¾¹ç•Œä¸‹ç§»
            upper_bound++
        }
        
        if left_bound <= right_bound {
            // åœ¨å³ä¾§ä»ä¸Šå‘ä¸‹éå†
            for i := upper_bound; i <= lower_bound; i++ {
                res = append(res, matrix[i][right_bound])
            }
            // å³è¾¹ç•Œå·¦ç§»
            right_bound--
        }
        
        if upper_bound <= lower_bound {
            // åœ¨åº•éƒ¨ä»å³å‘å·¦éå†
            for j := right_bound; j >= left_bound; j-- {
                res = append(res, matrix[lower_bound][j])
            }
            // ä¸‹è¾¹ç•Œä¸Šç§»
            lower_bound--
        }
        
        if left_bound <= right_bound {
            // åœ¨å·¦ä¾§ä»ä¸‹å‘ä¸Šéå†
            for i := lower_bound; i >= upper_bound; i-- {
                res = append(res, matrix[i][left_bound])
            }
            // å·¦è¾¹ç•Œå³ç§»
            left_bound++
        }
    }
    return res
}
```

##### 59.èºæ—‹çŸ©é˜µ II

ä¸ [54.èºæ—‹çŸ©é˜µ](https://leetcode.cn/problems/spiral-matrix-ii/description/) ä¸€é¢˜ç±»ä¼¼ï¼Œåªä¸è¿‡æ˜¯åè¿‡æ¥ï¼Œè®©ä½ æŒ‰ç…§èºæ—‹çš„é¡ºåºç”ŸæˆçŸ©é˜µï¼š

```go
func generateMatrix(n int) [][]int {
    matrix := make([][]int, n)
    for i := range matrix {
        matrix[i] = make([]int, n)
    }
    upper_bound, lower_bound := 0, n - 1
    left_bound, right_bound := 0, n - 1
    // éœ€è¦å¡«å…¥çŸ©é˜µçš„æ•°å­—
    num := 1

    for num <= n * n {
        if upper_bound <= lower_bound {
            // åœ¨é¡¶éƒ¨ä»å·¦å‘å³éå†
            for j := left_bound; j <= right_bound; j++ {
                matrix[upper_bound][j] = num
                num++
            }
            // ä¸Šè¾¹ç•Œä¸‹ç§»
            upper_bound++
        }

        if left_bound <= right_bound {
            // åœ¨å³ä¾§ä»ä¸Šå‘ä¸‹éå†
            for i := upper_bound; i <= lower_bound; i++ {
                matrix[i][right_bound] = num
                num++
            }
            // å³è¾¹ç•Œå·¦ç§»
            right_bound--
        }

        if upper_bound <= lower_bound {
            // åœ¨åº•éƒ¨ä»å³å‘å·¦éå†
            for j := right_bound; j >= left_bound; j-- {
                matrix[lower_bound][j] = num
                num++
            }
            // ä¸‹è¾¹ç•Œä¸Šç§»
            lower_bound--
        }

        if left_bound <= right_bound {
            // åœ¨å·¦ä¾§ä»ä¸‹å‘ä¸Šéå†
            for i := lower_bound; i >= upper_bound; i-- {
                matrix[i][left_bound] = num
                num++
            }
            // å·¦è¾¹ç•Œå³ç§»
            left_bound++
        }
    }
    return matrix
}
```

### å‰ç¼€å’Œ

#### [åŒºåŸŸå’Œæ£€ç´¢ - æ•°ç»„ä¸å¯å˜](https://leetcode.cn/problems/range-sum-query-immutable/description/)

ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ numsï¼Œå¤„ç†ä»¥ä¸‹ç±»å‹çš„å¤šä¸ªæŸ¥è¯¢ï¼š

è®¡ç®—ç´¢å¼• left å’Œ right ï¼ˆåŒ…å« left å’Œ rightï¼‰ä¹‹é—´çš„ nums å…ƒç´ çš„å’Œ ï¼Œå…¶ä¸­ left <= rightï¼Œå®ç° NumArray ç±»ï¼š

- `NumArray(int[] nums)` ä½¿ç”¨æ•°ç»„ nums åˆå§‹åŒ–å¯¹è±¡
- `int sumRange(int i, int j)` è¿”å›æ•°ç»„ nums ä¸­ç´¢å¼• left å’Œ right ä¹‹é—´çš„å…ƒç´ çš„ æ€»å’Œ ï¼ŒåŒ…å« left å’Œ right ä¸¤ç‚¹ï¼ˆä¹Ÿå°±æ˜¯ `nums[left] + nums[left + 1] + ... + nums[right]`)
 
ç¤ºä¾‹ 1ï¼š

```go
è¾“å…¥ï¼š
["NumArray", "sumRange", "sumRange", "sumRange"]
[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]
è¾“å‡ºï¼š
[null, 1, -1, -3]

è§£é‡Šï¼š
NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);
numArray.sumRange(0, 2); // return 1 ((-2) + 0 + 3)
numArray.sumRange(2, 5); // return -1 (3 + (-5) + 2 + (-1)) 
numArray.sumRange(0, 5); // return -3 ((-2) + 0 + 3 + (-5) + 2 + (-1))
```

`sumRange` å‡½æ•°éœ€è¦è®¡ç®—å¹¶è¿”å›ä¸€ä¸ªç´¢å¼•åŒºé—´ä¹‹å†…çš„å…ƒç´ å’Œï¼Œæ²¡å­¦è¿‡å‰ç¼€å’Œçš„äººå¯èƒ½å†™å‡ºå¦‚ä¸‹ä»£ç ï¼š

```go
type NumArray struct {
    nums []int
}

func Constructor(nums []int) NumArray {
    return NumArray {
        nums: nums,
    }
}

func (this *NumArray) SumRange(left int, right int) int {
    sum := 0
    for i := left; i <= right; i++ {
        sum += this.nums[i]
    }
    return sum
}
```

è¿™ä¸ªè§£æ³•æ¯æ¬¡è°ƒç”¨ sumRange å‡½æ•°æ—¶ï¼Œéƒ½è¦è¿›è¡Œä¸€æ¬¡ for å¾ªç¯éå†ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º O(N)ï¼Œè€Œ sumRange çš„è°ƒç”¨é¢‘ç‡å¯èƒ½éå¸¸é«˜ï¼Œæ‰€ä»¥è¿™ä¸ªç®—æ³•çš„æ•ˆç‡å¾ˆä½ã€‚

æ­£ç¡®çš„è§£æ³•æ˜¯ä½¿ç”¨å‰ç¼€å’ŒæŠ€å·§è¿›è¡Œä¼˜åŒ–ï¼Œä½¿å¾— sumRange å‡½æ•°çš„æ—¶é—´å¤æ‚åº¦ä¸º O(1)ï¼š

```go
type NumArray struct {
    // å‰ç¼€å’Œæ•°ç»„
    PreSum []int
}

// è¾“å…¥ä¸€ä¸ªæ•°ç»„ï¼Œæ„é€ å‰ç¼€å’Œ
func Constructor(nums []int) NumArray {
    // PreSum[0] = 0ï¼Œä¾¿äºè®¡ç®—ç´¯åŠ å’Œ
    preSum := make([]int, len(nums)+1)
    // è®¡ç®— nums çš„ç´¯åŠ å’Œ
    for i := 1; i < len(preSum); i++ {
        preSum[i] = preSum[i-1] + nums[i-1]
    }
    return NumArray{PreSum: preSum}
}

// æŸ¥è¯¢é—­åŒºé—´ [left, right] çš„ç´¯åŠ å’Œ
func (this *NumArray) SumRange(left int, right int) int {   
    return this.PreSum[right+1] - this.PreSum[left]
}
```

çœ‹è¿™ä¸ª preSum æ•°ç»„ï¼Œå¦‚æœæˆ‘æƒ³æ±‚ç´¢å¼•åŒºé—´ [0, 2] å†…çš„æ‰€æœ‰å…ƒç´ ä¹‹å’Œï¼Œå°±å¯ä»¥é€šè¿‡ preSum[3] - preSum[0] å¾—å‡ºï¼ˆç»“æœæ˜¯ 1ï¼‰ã€‚å¦‚æœæƒ³æ±‚ [2, 5] å†…çš„å…ƒç´ å’Œï¼Œåˆ™ç”¨ preSum[6] - preSum[2] å¾—å‡ºï¼ˆç»“æœæ˜¯ 3ï¼‰ã€‚å› ä¸ºä¸ºäº†ä¾¿äºè®¡ç®—ç´¯åŠ å’Œï¼Œå°† preSum[0] è®¾ç½®ä¸º 0ï¼Œæ‰€ä»¥åœ¨è®¡ç®—ç´¯åŠ å’Œæ—¶ preSum çš„ä¸‹æ ‡è¦åŠ  1ã€‚

![](https://chengzw258.oss-cn-beijing.aliyuncs.com/Article/202502081139215.png)

#### [304. äºŒç»´åŒºåŸŸå’Œæ£€ç´¢ - çŸ©é˜µä¸å¯å˜](https://leetcode.cn/problems/range-sum-query-2d-immutable/description/)

ç»™å®šä¸€ä¸ªäºŒç»´çŸ©é˜µ matrixï¼Œä»¥ä¸‹ç±»å‹çš„å¤šä¸ªè¯·æ±‚ï¼š

- è®¡ç®—å…¶å­çŸ©å½¢èŒƒå›´å†…å…ƒç´ çš„æ€»å’Œï¼Œè¯¥å­çŸ©é˜µçš„å·¦ä¸Šè§’ä¸º (row1, col1)ï¼Œå³ä¸‹è§’ ä¸º (row2, col2)ã€‚

å®ç° NumMatrix ç±»ï¼š

- `NumMatrix(int[][] matrix)` ç»™å®šæ•´æ•°çŸ©é˜µ matrix è¿›è¡Œåˆå§‹åŒ–
- `int sumRegion(int row1, int col1, int row2, int col2)` è¿”å›å·¦ä¸Šè§’ (row1, col1)ã€å³ä¸‹è§’ (row2, col2) æ‰€æè¿°çš„å­çŸ©é˜µçš„å…ƒç´ æ€»å’Œã€‚

ç¤ºä¾‹ 1ï¼š

![](https://chengzw258.oss-cn-beijing.aliyuncs.com/Article/202502081153958.png)

```go
è¾“å…¥: 
["NumMatrix","sumRegion","sumRegion","sumRegion"]
[[[[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]],[2,1,4,3],[1,1,2,2],[1,2,2,4]]
è¾“å‡º: 
[null, 8, 11, 12]

è§£é‡Š:
NumMatrix numMatrix = new NumMatrix([[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]);
numMatrix.sumRegion(2, 1, 4, 3); // return 8 (çº¢è‰²çŸ©å½¢æ¡†çš„å…ƒç´ æ€»å’Œ)
numMatrix.sumRegion(1, 1, 2, 2); // return 11 (ç»¿è‰²çŸ©å½¢æ¡†çš„å…ƒç´ æ€»å’Œ)
numMatrix.sumRegion(1, 2, 2, 4); // return 12 (è“è‰²çŸ©å½¢æ¡†çš„å…ƒç´ æ€»å’Œ)
```

ä»»æ„å­çŸ©é˜µçš„å…ƒç´ å’Œå¯ä»¥è½¬åŒ–æˆå®ƒå‘¨è¾¹å‡ ä¸ªå¤§çŸ©é˜µçš„å…ƒç´ å’Œçš„è¿ç®—ï¼š

![](https://chengzw258.oss-cn-beijing.aliyuncs.com/Article/202502081154238.png)

è€Œè¿™å››ä¸ªå¤§çŸ©é˜µæœ‰ä¸€ä¸ªå…±åŒçš„ç‰¹ç‚¹ï¼Œå°±æ˜¯å·¦ä¸Šè§’éƒ½æ˜¯ (0, 0) åŸç‚¹ã€‚

é‚£ä¹ˆåšè¿™é“é¢˜æ›´å¥½çš„æ€è·¯å’Œä¸€ç»´æ•°ç»„ä¸­çš„å‰ç¼€å’Œæ˜¯éå¸¸ç±»ä¼¼çš„ï¼Œæˆ‘ä»¬å¯ä»¥ç»´æŠ¤ä¸€ä¸ªäºŒç»´ preSum æ•°ç»„ï¼Œä¸“é—¨è®°å½•ä»¥åŸç‚¹ä¸ºé¡¶ç‚¹çš„çŸ©é˜µçš„å…ƒç´ ä¹‹å’Œï¼Œå°±å¯ä»¥ç”¨å‡ æ¬¡åŠ å‡è¿ç®—ç®—å‡ºä»»ä½•ä¸€ä¸ªå­çŸ©é˜µçš„å…ƒç´ å’Œï¼š

```go
type NumMatrix struct {
    // preSum[i][j] è®°å½•çŸ©é˜µ [0, 0, i-1, j-1] çš„å…ƒç´ å’Œ
    preSum [][]int
}

func Constructor(matrix [][]int) NumMatrix {
    // åˆå§‹åŒ–äºŒç»´æ•°ç»„
    preSum := make([][]int, len(matrix) + 1)
    for i := 0; i < len(preSum); i++ {
        preSum[i] = make([]int, len(matrix[0]) + 1)
    }

    // æ„å»ºå‰ç¼€å’Œæ•°ç»„
    // preSum[i][j] è®°å½•çŸ©é˜µ [0, 0, i-1, j-1] çš„å…ƒç´ å’Œ
    for i := 1; i < len(preSum); i ++ {
        for j := 1; j < len(preSum[0]); j++ {
            preSum[i][j] = preSum[i-1][j] + preSum[i][j-1] + matrix[i-1][j-1] - preSum[i-1][j-1];
        }
    }
    return NumMatrix{preSum}
}

func (this *NumMatrix) SumRegion(row1 int, col1 int, row2 int, col2 int) int {
    return this.preSum[row2+1][col2+1] - this.preSum[row1][col2+1] - this.preSum[row2+1][col1] + this.preSum[row1][col1] 
}
```

#### [å’Œä¸º K çš„å­æ•°ç»„](https://leetcode.cn/problems/subarray-sum-equals-k/description/)

ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ nums å’Œä¸€ä¸ªæ•´æ•° kï¼Œè¯·ä½ ç»Ÿè®¡å¹¶è¿”å›è¯¥æ•°ç»„ä¸­å’Œä¸º k çš„å­æ•°ç»„çš„ä¸ªæ•°ã€‚

å­æ•°ç»„æ˜¯æ•°ç»„ä¸­å…ƒç´ çš„è¿ç»­éç©ºåºåˆ—ã€‚

ç¤ºä¾‹ 1ï¼š

```go
è¾“å…¥ï¼šnums = [1,1,1], k = 2
è¾“å‡ºï¼š2
```

ç¤ºä¾‹ 2ï¼š

```go
è¾“å…¥ï¼šnums = [1,2,3], k = 3
è¾“å‡ºï¼š2
```

- ç”¨ prefixSum è¡¨ç¤ºå½“å‰çš„å‰ç¼€å’Œã€‚
- ç»´æŠ¤ä¸€ä¸ªå“ˆå¸Œè¡¨ countMapï¼Œå…¶ä¸­é”®ä¸ºå‰ç¼€å’Œï¼Œå€¼ä¸ºè¯¥å‰ç¼€å’Œå‡ºç°çš„æ¬¡æ•°ã€‚
- éå†æ•°ç»„æ—¶ï¼Œé€šè¿‡ prefixSum - k åˆ¤æ–­æ˜¯å¦å­˜åœ¨ä¹‹å‰çš„å‰ç¼€å’Œæ»¡è¶³æ¡ä»¶ã€‚

```go
func subarraySum(nums []int, k int) int {
    countMap := make(map[int]int)
    countMap[0] = 1 // åˆå§‹å‰ç¼€å’Œä¸º 0 çš„æƒ…å†µ
    prefixSum := 0
    count := 0

    for _, num := range nums {
        prefixSum += num
        // æ£€æŸ¥æ˜¯å¦å­˜åœ¨å‰ç¼€å’Œä½¿å¾—å½“å‰å­æ•°ç»„å’Œä¸º k
        if val, exists := countMap[prefixSum-k]; exists {
            count += val
        }
        // æ›´æ–°å½“å‰å‰ç¼€å’Œçš„å‡ºç°æ¬¡æ•°
        countMap[prefixSum]++
    }

    return count
}
```

æ ¸å¿ƒæ€æƒ³ï¼šå¯¹äºå½“å‰çš„å‰ç¼€å’Œ prefixSumï¼Œå¦‚æœå­˜åœ¨ä¹‹å‰çš„æŸä¸ªå‰ç¼€å’Œä¸º prefixSum - kï¼Œé‚£ä¹ˆä»è¯¥ä½ç½®åˆ°å½“å‰ä½ç½®çš„å­æ•°ç»„å’Œå³ä¸º kã€‚è¯¥å‰ç¼€å’Œå‡ºç°çš„æ¬¡æ•°å†³å®šäº†èƒ½ç»„æˆå¤šå°‘ä¸ªæ»¡è¶³æ¡ä»¶çš„å­æ•°ç»„ã€‚

![](https://chengzw258.oss-cn-beijing.aliyuncs.com/Article/202502081311832.png)

### å·®åˆ†æ•°ç»„

å·®åˆ†æ•°ç»„çš„ä¸»è¦é€‚ç”¨åœºæ™¯æ˜¯é¢‘ç¹å¯¹åŸå§‹æ•°ç»„çš„æŸä¸ªåŒºé—´çš„å…ƒç´ è¿›è¡Œå¢å‡ã€‚

æ¯”å¦‚è¯´ï¼Œæˆ‘ç»™ä½ è¾“å…¥ä¸€ä¸ªæ•°ç»„ numsï¼Œç„¶ååˆè¦æ±‚ç»™åŒºé—´ nums[2..6] å…¨éƒ¨åŠ  1ï¼Œå†ç»™ nums[3..9] å…¨éƒ¨å‡ 3ï¼Œå†ç»™ nums[0..4] å…¨éƒ¨åŠ  2...

#### [370.åŒºé—´åŠ æ³•](https://leetcode.cn/problems/range-addition/description/)

å‡è®¾ä½ æœ‰ä¸€ä¸ªé•¿åº¦ä¸º n çš„æ•°ç»„ï¼Œåˆå§‹æƒ…å†µä¸‹æ‰€æœ‰çš„æ•°å­—å‡ä¸º 0ï¼Œä½ å°†ä¼šè¢«ç»™å‡º kâ€‹â€‹â€‹â€‹â€‹â€‹â€‹ ä¸ªæ›´æ–°çš„æ“ä½œã€‚

å…¶ä¸­ï¼Œæ¯ä¸ªæ“ä½œä¼šè¢«è¡¨ç¤ºä¸ºä¸€ä¸ªä¸‰å…ƒç»„ï¼š[startIndex, endIndex, inc]ï¼Œä½ éœ€è¦å°†å­æ•°ç»„ A[startIndex ... endIndex]ï¼ˆåŒ…æ‹¬ startIndex å’Œ endIndexï¼‰å¢åŠ  incã€‚

è¯·ä½ è¿”å› k æ¬¡æ“ä½œåçš„æ•°ç»„ã€‚

ç¤ºä¾‹ï¼š

```go
è¾“å…¥: length = 5, updates = [[1,3,2],[2,4,3],[0,2,-2]]
è¾“å‡º: [-2,0,3,5,3]

è§£é‡Š:
åˆå§‹çŠ¶æ€:
[0,0,0,0,0]

è¿›è¡Œäº†æ“ä½œ [1,3,2] åçš„çŠ¶æ€:
[0,2,2,2,0]

è¿›è¡Œäº†æ“ä½œ [2,4,3] åçš„çŠ¶æ€:
[0,2,5,5,3]

è¿›è¡Œäº†æ“ä½œ [0,2,-2] åçš„çŠ¶æ€:
[-2,0,3,5,3]
```

è§£æ³•å¦‚ä¸‹ï¼š

```go
func getModifiedArray(length int, updates [][]int) []int {
    // nums åˆå§‹åŒ–ä¸ºå…¨ 0
    nums := make([]int, length)
    // æ„é€ å·®åˆ†è§£æ³•
    df := NewDifference(nums)
    for _, update := range updates {
        i, j, val := update[0], update[1], update[2]
        df.Increment(i, j, val)
    }
    return df.Result()
}

// å·®åˆ†æ•°ç»„
type Difference struct {
    diff []int
}

func NewDifference(nums []int) *Difference {
    assert(len(nums) > 0)
    diff := make([]int, len(nums))
    // æ„é€ å·®åˆ†æ•°ç»„
    diff[0] = nums[0]
    for i := 1; i < len(nums); i++ {
        diff[i] = nums[i] - nums[i-1]
    }
    return &Difference{diff: diff}
}

// ç»™é—­åŒºé—´ [i, j] å¢åŠ  valï¼ˆå¯ä»¥æ˜¯è´Ÿæ•°ï¼‰
func (d *Difference) Increment(i, j, val int) {
    d.diff[i] += val
    if j+1 < len(d.diff) {
        d.diff[j+1] -= val
    }
}

// æ ¹æ®å·®åˆ†æ•°ç»„æ„é€ ç»“æœæ•°ç»„
func (d *Difference) Result() []int {
    res := make([]int, len(d.diff))
    // æ ¹æ®å·®åˆ†æ•°ç»„æ„é€ ç»“æœæ•°ç»„
    res[0] = d.diff[0]
    for i := 1; i < len(d.diff); i++ {
        res[i] = res[i-1] + d.diff[i]
    }
    return res
}

func assert(condition bool) {
    if !condition {
        panic("condition failed")
    }
}
```

## æ ˆ

### [71.ç®€åŒ–è·¯å¾„](https://leetcode.cn/problems/simplify-path/description/)

ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸² pathï¼Œè¡¨ç¤ºæŒ‡å‘æŸä¸€æ–‡ä»¶æˆ–ç›®å½•çš„ Unix é£æ ¼ç»å¯¹è·¯å¾„ ï¼ˆä»¥ '/' å¼€å¤´ï¼‰ï¼Œè¯·ä½ å°†å…¶è½¬åŒ–ä¸ºæ›´åŠ ç®€æ´çš„è§„èŒƒè·¯å¾„ã€‚

åœ¨ Unix é£æ ¼çš„æ–‡ä»¶ç³»ç»Ÿä¸­è§„åˆ™å¦‚ä¸‹ï¼š

- ä¸€ä¸ªç‚¹ '.' è¡¨ç¤ºå½“å‰ç›®å½•æœ¬èº«ã€‚
- æ­¤å¤–ï¼Œä¸¤ä¸ªç‚¹ '..' è¡¨ç¤ºå°†ç›®å½•åˆ‡æ¢åˆ°ä¸Šä¸€çº§ï¼ˆæŒ‡å‘çˆ¶ç›®å½•ï¼‰ã€‚
- ä»»æ„å¤šä¸ªè¿ç»­çš„æ–œæ ï¼ˆå³ï¼Œ'//' æˆ– '///'ï¼‰éƒ½è¢«è§†ä¸ºå•ä¸ªæ–œæ  '/'ã€‚
- ä»»ä½•å…¶ä»–æ ¼å¼çš„ç‚¹ï¼ˆä¾‹å¦‚ï¼Œ'...' æˆ– '....'ï¼‰å‡è¢«è§†ä¸ºæœ‰æ•ˆçš„æ–‡ä»¶/ç›®å½•åç§°ã€‚

è¿”å›çš„ ç®€åŒ–è·¯å¾„ å¿…é¡»éµå¾ªä¸‹è¿°æ ¼å¼ï¼š

- å§‹ç»ˆä»¥æ–œæ  '/' å¼€å¤´ã€‚
- ä¸¤ä¸ªç›®å½•åä¹‹é—´å¿…é¡»åªæœ‰ä¸€ä¸ªæ–œæ  '/'ã€‚
- æœ€åä¸€ä¸ªç›®å½•åï¼ˆå¦‚æœå­˜åœ¨ï¼‰ä¸èƒ½ ä»¥ '/' ç»“å°¾ã€‚
- æ­¤å¤–ï¼Œè·¯å¾„ä»…åŒ…å«ä»æ ¹ç›®å½•åˆ°ç›®æ ‡æ–‡ä»¶æˆ–ç›®å½•çš„è·¯å¾„ä¸Šçš„ç›®å½•ï¼ˆå³ï¼Œä¸å« '.' æˆ– '..'ï¼‰ã€‚

è¿”å›ç®€åŒ–åå¾—åˆ°çš„è§„èŒƒè·¯å¾„ã€‚

ç¤ºä¾‹ 1ï¼š

```go
è¾“å…¥ï¼špath = "/home/"
è¾“å‡ºï¼š"/home"
è§£é‡Šï¼š
åº”åˆ é™¤å°¾éšæ–œæ ã€‚
```

ç¤ºä¾‹ 2ï¼š

```go
è¾“å…¥ï¼špath = "/home//foo/"
è¾“å‡ºï¼š"/home/foo"
è§£é‡Šï¼š
å¤šä¸ªè¿ç»­çš„æ–œæ è¢«å•ä¸ªæ–œæ æ›¿æ¢ã€‚
```

ç¤ºä¾‹ 3ï¼š

```go
è¾“å…¥ï¼špath = "/home/user/Documents/../Pictures"
è¾“å‡ºï¼š"/home/user/Pictures"
è§£é‡Šï¼š
ä¸¤ä¸ªç‚¹ ".." è¡¨ç¤ºä¸Šä¸€çº§ç›®å½•ï¼ˆçˆ¶ç›®å½•ï¼‰ã€‚
```

è¿™é¢˜æ¯”è¾ƒç®€å•ï¼Œåˆ©ç”¨æ ˆå…ˆè¿›åå‡ºçš„ç‰¹æ€§å¤„ç†ä¸Šçº§ç›®å½• `..`ï¼Œæœ€åç»„è£…åŒ–ç®€åçš„è·¯å¾„å³å¯ã€‚

```go
func simplifyPath(path string) string {
    parts := strings.Split(path, "/")
    stk := []string{}
    // å€ŸåŠ©æ ˆè®¡ç®—æœ€ç»ˆçš„æ–‡ä»¶å¤¹è·¯å¾„
    for _, part := range parts {
        if part == "" || part == "." {
            continue
        }
        if part == ".." {
            if len(stk) > 0 {
                stk = stk[:len(stk)-1]
            }
            continue
        }
        stk = append(stk, part)
    }
    // æ ˆä¸­å­˜å‚¨çš„æ–‡ä»¶å¤¹ç»„æˆè·¯å¾„
    res := ""
    for _, dir := range stk {
        res += "/" + dir
    }
    if res == "" {
        return "/"
    }
    return res
}
```

## BFS

### [773.æ»‘åŠ¨è°œé¢˜](https://leetcode.cn/problems/sliding-puzzle/description/)

åœ¨ä¸€ä¸ª 2 x 3 çš„æ¿ä¸Šï¼ˆboardï¼‰æœ‰ 5 å—ç –ç“¦ï¼Œç”¨æ•°å­— 1~5 æ¥è¡¨ç¤º, ä»¥åŠä¸€å—ç©ºç¼ºç”¨ 0 æ¥è¡¨ç¤ºã€‚ä¸€æ¬¡ç§»åŠ¨å®šä¹‰ä¸ºé€‰æ‹© 0 ä¸ä¸€ä¸ªç›¸é‚»çš„æ•°å­—ï¼ˆä¸Šä¸‹å·¦å³ï¼‰è¿›è¡Œäº¤æ¢ã€‚

æœ€ç»ˆå½“æ¿ board çš„ç»“æœæ˜¯ [[1,2,3],[4,5,0]] è°œæ¿è¢«è§£å¼€ã€‚

ç»™å‡ºä¸€ä¸ªè°œæ¿çš„åˆå§‹çŠ¶æ€ boardï¼Œè¿”å›æœ€å°‘å¯ä»¥é€šè¿‡å¤šå°‘æ¬¡ç§»åŠ¨è§£å¼€è°œæ¿ï¼Œå¦‚æœä¸èƒ½è§£å¼€è°œæ¿ï¼Œåˆ™è¿”å› -1ã€‚

ç¤ºä¾‹ 1ï¼š

![](https://chengzw258.oss-cn-beijing.aliyuncs.com/Article/202502101949105.png)

```go
è¾“å…¥ï¼šboard = [[4,1,2],[5,0,3]]
è¾“å‡ºï¼š5
è§£é‡Šï¼š
æœ€å°‘å®Œæˆè°œæ¿çš„æœ€å°‘ç§»åŠ¨æ¬¡æ•°æ˜¯ 5 ï¼Œ
ä¸€ç§ç§»åŠ¨è·¯å¾„:
å°šæœªç§»åŠ¨: [[4,1,2],[5,0,3]]
ç§»åŠ¨ 1 æ¬¡: [[4,1,2],[0,5,3]]
ç§»åŠ¨ 2 æ¬¡: [[0,1,2],[4,5,3]]
ç§»åŠ¨ 3 æ¬¡: [[1,0,2],[4,5,3]]
ç§»åŠ¨ 4 æ¬¡: [[1,2,0],[4,5,3]]
ç§»åŠ¨ 5 æ¬¡: [[1,2,3],[4,5,0]]
```

ç”±äº**æ¯ä¸€æ­¥æ“ä½œç­‰ä»·äºåœ¨å›¾ä¸­æœç´¢æœ€çŸ­è·¯å¾„**ï¼Œæœ€ä¼˜è§£è‡ªç„¶æ˜¯ **BFS**ï¼š
1. **å°†åˆå§‹æ£‹ç›˜çŠ¶æ€è½¬æ¢ä¸ºå­—ç¬¦ä¸²**ï¼ˆä¾‹å¦‚ `412503`ï¼‰ã€‚
2. **ä½¿ç”¨é˜Ÿåˆ— `queue` è¿›è¡Œ BFS**ï¼š
   - æ¯æ¬¡å¼¹å‡ºé˜Ÿåˆ—çš„**å½“å‰çŠ¶æ€**ï¼Œæ‰¾åˆ° `0` çš„ç´¢å¼•ã€‚
   - æ ¹æ® **`0` åœ¨æ£‹ç›˜ä¸Šçš„ä½ç½®ï¼Œç¡®å®šå®ƒå¯ä»¥ç§»åŠ¨çš„æ–¹å‘**ï¼ˆä½¿ç”¨ `dirs` æ•°ç»„ï¼‰ã€‚
   - **ç”Ÿæˆæ–°çŠ¶æ€**ï¼Œè‹¥æœªè®¿é—®ï¼Œåˆ™åŠ å…¥ `queue`ã€‚
   - **å¦‚æœç”Ÿæˆçš„çŠ¶æ€ç­‰äºç›®æ ‡çŠ¶æ€ï¼Œç›´æ¥è¿”å›æ­¥æ•°**ã€‚
3. **ä½¿ç”¨ `visited` é›†åˆå»é‡**ï¼Œé˜²æ­¢é‡å¤æœç´¢ã€‚
4. è‹¥ `queue` ä¸ºç©ºä»æœªæ‰¾åˆ°ç›®æ ‡çŠ¶æ€ï¼Œè¯´æ˜æ— è§£ï¼Œè¿”å› `-1`ã€‚

```go
func slidingPuzzle(board [][]int) int {
    target := "123450"
    // å°† 2x3 çš„æ•°ç»„è½¬åŒ–æˆå­—ç¬¦ä¸²ä½œä¸º BFS çš„èµ·ç‚¹
    start := ""
    for i := 0; i < len(board); i++ {
        for j := 0; j < len(board[0]); j++ {
            start += string(board[i][j] + '0')
        }
    }

    // ****** BFS ç®—æ³•æ¡†æ¶å¼€å§‹ ******
    queue := []string{start}
    visited := make(map[string]bool)
    visited[start] = true

    step := 0
    for len(queue) > 0 {
        sz := len(queue)
        for i := 0; i < sz; i++ {
            cur := queue[0]
            queue = queue[1:]
            // åˆ¤æ–­æ˜¯å¦è¾¾åˆ°ç›®æ ‡å±€é¢
            if cur == target {
                return step
            }
            // å°†æ•°å­— 0 å’Œç›¸é‚»çš„æ•°å­—äº¤æ¢ä½ç½®
            for _, neighbor := range getNeighbors(cur) {
                // é˜²æ­¢èµ°å›å¤´è·¯
                if !visited[neighbor] {
                    queue = append(queue, neighbor)
                    visited[neighbor] = true
                }
            }
        }
        step++
    }
    // ****** BFS ç®—æ³•æ¡†æ¶ç»“æŸ ******
    return -1
}

func getNeighbors(board string) []string {
    // è®°å½•ä¸€ç»´å­—ç¬¦ä¸²çš„ç›¸é‚»ç´¢å¼•
    mapping := [][]int{
        {1, 3},
        {0, 4, 2},
        {1, 5},
        {0, 4},
        {3, 1, 5},
        {4, 2},
    }

    idx := strings.Index(board, "0")
    neighbors := []string{}
    for _, adj := range mapping[idx] {
        newBoard := swap(board, idx, adj)
        neighbors = append(neighbors, newBoard)
    }
    return neighbors
}

func swap(board string, i, j int) string {
    chars := []rune(board)
    chars[i], chars[j] = chars[j], chars[i]
    return string(chars)
}
```

### [752.æ‰“å¼€è½¬ç›˜é”](https://leetcode.cn/problems/open-the-lock/description/)

ä½ æœ‰ä¸€ä¸ªå¸¦æœ‰å››ä¸ªåœ†å½¢æ‹¨è½®çš„è½¬ç›˜é”ã€‚æ¯ä¸ªæ‹¨è½®éƒ½æœ‰10ä¸ªæ•°å­—ï¼š'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'ã€‚æ¯ä¸ªæ‹¨è½®å¯ä»¥è‡ªç”±æ—‹è½¬ï¼šä¾‹å¦‚æŠŠ '9' å˜ä¸º '0'ï¼Œ'0' å˜ä¸º '9'ã€‚æ¯æ¬¡æ—‹è½¬éƒ½åªèƒ½æ—‹è½¬ä¸€ä¸ªæ‹¨è½®çš„ä¸€ä½æ•°å­—ã€‚

é”çš„åˆå§‹æ•°å­—ä¸º '0000' ï¼Œä¸€ä¸ªä»£è¡¨å››ä¸ªæ‹¨è½®çš„æ•°å­—çš„å­—ç¬¦ä¸²ã€‚

åˆ—è¡¨ deadends åŒ…å«äº†ä¸€ç»„æ­»äº¡æ•°å­—ï¼Œä¸€æ—¦æ‹¨è½®çš„æ•°å­—å’Œåˆ—è¡¨é‡Œçš„ä»»ä½•ä¸€ä¸ªå…ƒç´ ç›¸åŒï¼Œè¿™ä¸ªé”å°†ä¼šè¢«æ°¸ä¹…é”å®šï¼Œæ— æ³•å†è¢«æ—‹è½¬ã€‚

å­—ç¬¦ä¸² target ä»£è¡¨å¯ä»¥è§£é”çš„æ•°å­—ï¼Œä½ éœ€è¦ç»™å‡ºè§£é”éœ€è¦çš„æœ€å°æ—‹è½¬æ¬¡æ•°ï¼Œå¦‚æœæ— è®ºå¦‚ä½•ä¸èƒ½è§£é”ï¼Œè¿”å› -1ã€‚

ç¤ºä¾‹ 1:

```go
è¾“å…¥ï¼šdeadends = ["0201","0101","0102","1212","2002"], target = "0202"
è¾“å‡ºï¼š6
è§£é‡Šï¼š
å¯èƒ½çš„ç§»åŠ¨åºåˆ—ä¸º "0000" -> "1000" -> "1100" -> "1200" -> "1201" -> "1202" -> "0202"ã€‚
æ³¨æ„ "0000" -> "0001" -> "0002" -> "0102" -> "0202" è¿™æ ·çš„åºåˆ—æ˜¯ä¸èƒ½è§£é”çš„ï¼Œ
å› ä¸ºå½“æ‹¨åŠ¨åˆ° "0102" æ—¶è¿™ä¸ªé”å°±ä¼šè¢«é”å®šã€‚
```

æ ¸å¿ƒæ€è·¯ï¼š
1. **åˆå§‹åŒ–**ï¼š
   - ä½¿ç”¨ä¸€ä¸ªå“ˆå¸Œè¡¨ `deads` æ¥å­˜å‚¨æ‰€æœ‰çš„æ­»äº¡å¯†ç ï¼Œæ–¹ä¾¿å¿«é€ŸæŸ¥æ‰¾ã€‚
   - ä½¿ç”¨å¦ä¸€ä¸ªå“ˆå¸Œè¡¨ `visited` æ¥è®°å½•å·²ç»è®¿é—®è¿‡çš„å¯†ç ï¼Œé¿å…é‡å¤è®¿é—®ã€‚
   - ä½¿ç”¨ä¸€ä¸ªé˜Ÿåˆ— `q` æ¥è¿›è¡Œå¹¿åº¦ä¼˜å…ˆæœç´¢ï¼Œåˆå§‹æ—¶å°†èµ·ç‚¹ `"0000"` åŠ å…¥é˜Ÿåˆ—ã€‚

2. **å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ˆBFSï¼‰**ï¼š
   - ä»é˜Ÿåˆ—ä¸­å–å‡ºå½“å‰å±‚çš„æ‰€æœ‰èŠ‚ç‚¹ï¼ˆå¯†ç ï¼‰ï¼Œå¹¶å°è¯•é€šè¿‡æ‹¨åŠ¨å¯†ç é”çš„æ¯ä¸€ä½ï¼ˆå‘ä¸Šæˆ–å‘ä¸‹ï¼‰ç”Ÿæˆæ–°çš„å¯†ç ã€‚
   - å¯¹äºæ¯ä¸€ä¸ªæ–°ç”Ÿæˆçš„å¯†ç ï¼Œæ£€æŸ¥å®ƒæ˜¯å¦æ˜¯ç›®æ ‡å¯†ç ã€‚å¦‚æœæ˜¯ï¼Œè¿”å›å½“å‰çš„æ­¥æ•°ã€‚
   - å¦‚æœæ–°å¯†ç ä¸æ˜¯æ­»äº¡å¯†ç ä¸”æ²¡æœ‰è¢«è®¿é—®è¿‡ï¼Œåˆ™å°†å…¶åŠ å…¥é˜Ÿåˆ—ï¼Œå¹¶æ ‡è®°ä¸ºå·²è®¿é—®ã€‚
   - æ¯å¤„ç†å®Œä¸€å±‚èŠ‚ç‚¹ï¼ˆå³å½“å‰é˜Ÿåˆ—ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹ï¼‰ï¼Œæ­¥æ•°åŠ ä¸€ã€‚

3. **ç”Ÿæˆç›¸é‚»å¯†ç **ï¼š
   - `getNeighbors` å‡½æ•°ç”¨äºç”Ÿæˆå½“å‰å¯†ç çš„æ‰€æœ‰å¯èƒ½ç›¸é‚»å¯†ç ã€‚å¯¹äºå¯†ç çš„æ¯ä¸€ä½ï¼Œåˆ†åˆ«å‘ä¸Šæ‹¨åŠ¨ä¸€æ¬¡å’Œå‘ä¸‹æ‹¨åŠ¨ä¸€æ¬¡ï¼Œå…±ç”Ÿæˆ 8 ç§å¯èƒ½çš„ç›¸é‚»å¯†ç ã€‚

4. **ç»ˆæ­¢æ¡ä»¶**ï¼š
   - å¦‚æœé˜Ÿåˆ—ä¸ºç©ºä¸”æ²¡æœ‰æ‰¾åˆ°ç›®æ ‡å¯†ç ï¼Œè¯´æ˜æ— æ³•åˆ°è¾¾ç›®æ ‡å¯†ç ï¼Œè¿”å› `-1`ã€‚

```go
func openLock(deadends []string, target string) int {
    // è®°å½•éœ€è¦è·³è¿‡çš„æ­»äº¡å¯†ç 
    deads := make(map[string]struct{})
    for _, s := range deadends {
        deads[s] = struct{}{}
    }
    if _, found := deads["0000"]; found {
        return -1
    }

    // è®°å½•å·²ç»ç©·ä¸¾è¿‡çš„å¯†ç ï¼Œé˜²æ­¢èµ°å›å¤´è·¯
    visited := make(map[string]struct{})
    q := make([]string, 0)
    // ä»èµ·ç‚¹å¼€å§‹å¯åŠ¨å¹¿åº¦ä¼˜å…ˆæœç´¢
    step := 0
    q = append(q, "0000")
    visited["0000"] = struct{}{}
    
    for len(q) > 0 {
        sz := len(q)
        // å°†å½“å‰é˜Ÿåˆ—ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹å‘å‘¨å›´æ‰©æ•£
        for i := 0; i < sz; i++ {
            cur := q[0]
            q = q[1:]
            
            // åˆ¤æ–­æ˜¯å¦åˆ°è¾¾ç»ˆç‚¹
            if cur == target {
                return step
            }
            
            // å°†ä¸€ä¸ªèŠ‚ç‚¹çš„åˆæ³•ç›¸é‚»èŠ‚ç‚¹åŠ å…¥é˜Ÿåˆ—
            for _, neighbor := range getNeighbors(cur) {
                if _, found := visited[neighbor]; !found {
                    if _, dead := deads[neighbor]; !dead {
                        q = append(q, neighbor)
                        visited[neighbor] = struct{}{}
                    }
                }
            }
        }
        // åœ¨è¿™é‡Œå¢åŠ æ­¥æ•°
        step++
    }
    // å¦‚æœç©·ä¸¾å®Œéƒ½æ²¡æ‰¾åˆ°ç›®æ ‡å¯†ç ï¼Œé‚£å°±æ˜¯æ‰¾ä¸åˆ°äº†
    return -1
}

// å°† s[j] å‘ä¸Šæ‹¨åŠ¨ä¸€æ¬¡
func plusOne(s string, j int) string {
    ch := []rune(s)
    if ch[j] == '9' {
        ch[j] = '0'
    } else {
        ch[j]++
    }
    return string(ch)
}

// å°† s[i] å‘ä¸‹æ‹¨åŠ¨ä¸€æ¬¡
func minusOne(s string, j int) string {
    ch := []rune(s)
    if ch[j] == '0' {
        ch[j] = '9'
    } else {
        ch[j]--
    }
    return string(ch)
}

// å°† s çš„æ¯ä¸€ä½å‘ä¸Šæ‹¨åŠ¨ä¸€æ¬¡æˆ–å‘ä¸‹æ‹¨åŠ¨ä¸€æ¬¡ï¼Œ8 ç§ç›¸é‚»å¯†ç 
func getNeighbors(s string) []string {
    neighbors := make([]string, 0)
    for i := 0; i < 4; i++ {
        neighbors = append(neighbors, plusOne(s, i))
        neighbors = append(neighbors, minusOne(s, i))
    }
    return neighbors
}
```

### [919.å®Œå…¨äºŒå‰æ ‘æ’å…¥å™¨](https://leetcode.cn/problems/complete-binary-tree-inserter/description/)

å®Œå…¨äºŒå‰æ ‘ æ˜¯æ¯ä¸€å±‚ï¼ˆé™¤æœ€åä¸€å±‚å¤–ï¼‰éƒ½æ˜¯å®Œå…¨å¡«å……ï¼ˆå³ï¼ŒèŠ‚ç‚¹æ•°è¾¾åˆ°æœ€å¤§ï¼‰çš„ï¼Œå¹¶ä¸”æ‰€æœ‰çš„èŠ‚ç‚¹éƒ½å°½å¯èƒ½åœ°é›†ä¸­åœ¨å·¦ä¾§ã€‚

è®¾è®¡ä¸€ç§ç®—æ³•ï¼Œå°†ä¸€ä¸ªæ–°èŠ‚ç‚¹æ’å…¥åˆ°ä¸€æ£µå®Œå…¨äºŒå‰æ ‘ä¸­ï¼Œå¹¶åœ¨æ’å…¥åä¿æŒå…¶å®Œæ•´ã€‚å®ç° CBTInserter ç±»:

- `CBTInserter(TreeNode root)` ä½¿ç”¨å¤´èŠ‚ç‚¹ä¸º root çš„ç»™å®šæ ‘åˆå§‹åŒ–è¯¥æ•°æ®ç»“æ„ï¼›
- `CBTInserter.insert(int v)` å‘æ ‘ä¸­æ’å…¥ä¸€ä¸ªå€¼ä¸º `Node.val == val` çš„æ–°èŠ‚ç‚¹ TreeNodeã€‚ä½¿æ ‘ä¿æŒå®Œå…¨äºŒå‰æ ‘çš„çŠ¶æ€ï¼Œå¹¶è¿”å›æ’å…¥èŠ‚ç‚¹ TreeNode çš„çˆ¶èŠ‚ç‚¹çš„å€¼ï¼›
- `CBTInserter.get_root()` å°†è¿”å›æ ‘çš„å¤´èŠ‚ç‚¹ã€‚

æ ¸å¿ƒæ€è·¯ï¼š

`CBTInserter`ï¼ˆå®Œå…¨äºŒå‰æ ‘æ’å…¥å™¨ï¼‰ç”¨äºåœ¨å®Œå…¨äºŒå‰æ ‘ä¸­æŒ‰ç…§å±‚åºæ’å…¥èŠ‚ç‚¹ï¼ŒåŒæ—¶ä¿æŒå…¶å®Œå…¨äºŒå‰æ ‘çš„æ€§è´¨ã€‚

**1. ç»“æ„å®šä¹‰**
- `q`: ç»´æŠ¤ä¸€ä¸ªé˜Ÿåˆ—ï¼Œä»…å­˜å‚¨å½“å‰äºŒå‰æ ‘åº•éƒ¨ **å¯ä»¥è¿›è¡Œæ’å…¥çš„èŠ‚ç‚¹**ï¼ˆå³è‡³å°‘æœ‰ä¸€ä¸ªå­èŠ‚ç‚¹ä¸ºç©ºï¼‰ã€‚
- `root`: æŒ‡å‘äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ã€‚

**2. æ„é€ å‡½æ•° (`Constructor`)**
- é‡‡ç”¨ **å¹¿åº¦ä¼˜å…ˆéå† (BFS)** éå†æ•´æ£µæ ‘ï¼Œæ‰¾åˆ°æ‰€æœ‰å¯ä»¥æ’å…¥çš„èŠ‚ç‚¹ï¼ˆå³å…¶ **å·¦æˆ–å³å­èŠ‚ç‚¹ä¸ºç©º**ï¼‰ã€‚
- è¿™äº›èŠ‚ç‚¹å­˜å…¥ `q`ï¼Œç”¨äºåç»­æ’å…¥æ“ä½œã€‚

**3. æ’å…¥ (`Insert`)**
- è·å– `q` ä¸­çš„é˜Ÿé¦–èŠ‚ç‚¹ `cur` ä½œä¸ºçˆ¶èŠ‚ç‚¹ï¼š
  - è‹¥ `cur.Left` ä¸ºç©ºï¼Œåˆ™æ’å…¥å·¦å­èŠ‚ç‚¹ã€‚
  - å¦åˆ™ï¼Œæ’å…¥å³å­èŠ‚ç‚¹ï¼Œå¹¶ **å°† `cur` å‡ºé˜Ÿ**ï¼Œå› ä¸ºå®ƒçš„å­èŠ‚ç‚¹å·²æ»¡ã€‚
- æ–°æ’å…¥çš„èŠ‚ç‚¹åŒæ ·å¯ä»¥æ¥æ”¶æ–°çš„å­èŠ‚ç‚¹ï¼Œå› æ­¤ **åŠ å…¥ `q` é˜Ÿåˆ—**ã€‚

**4. è·å–æ ¹èŠ‚ç‚¹ (`Get_root`)**
- ç›´æ¥è¿”å› `root`ï¼Œä¿è¯è°ƒç”¨è€…å¯ä»¥è®¿é—®æ•´ä¸ªäºŒå‰æ ‘ã€‚

```go
type CBTInserter struct {
    // è¿™ä¸ªé˜Ÿåˆ—åªè®°å½•å®Œå…¨äºŒå‰æ ‘åº•éƒ¨å¯ä»¥è¿›è¡Œæ’å…¥çš„èŠ‚ç‚¹
    q []*TreeNode
    root *TreeNode
}

func Constructor(root *TreeNode) CBTInserter {
    // è¿›è¡Œæ™®é€šçš„ BFSï¼Œç›®çš„æ˜¯æ‰¾åˆ°åº•éƒ¨å¯æ’å…¥çš„èŠ‚ç‚¹
    q := []*TreeNode{}
    // temp æ˜¯ä¸ºäº†éå†äºŒå‰æ ‘
    temp := []*TreeNode{root}
    for len(temp) > 0 {
        cur := temp[0]
        temp = temp[1:]
        if cur.Left != nil {
            temp = append(temp, cur.Left)
        }
        if cur.Right != nil {
            temp = append(temp, cur.Right)
        }
        if cur.Right == nil || cur.Left == nil {
            // æ‰¾åˆ°å®Œå…¨äºŒå‰æ ‘åº•éƒ¨å¯ä»¥è¿›è¡Œæ’å…¥çš„èŠ‚ç‚¹
            q = append(q, cur)
        }
    }
    return CBTInserter{q: q, root: root}
}

func (this *CBTInserter) Insert(val int) int {
    node := &TreeNode{Val: val}
    cur := this.q[0]
    // è¿›è¡Œæ’å…¥
    if cur.Left == nil {
        cur.Left = node
    } else if cur.Right == nil {
        cur.Right = node
        // æ’å…¥å³å­èŠ‚ç‚¹ï¼Œå¹¶å°† cur å‡ºé˜Ÿï¼Œå› ä¸ºå®ƒçš„å­èŠ‚ç‚¹å·²æ»¡ã€‚
        this.q = this.q[1:]
    }
    // æ–°èŠ‚ç‚¹çš„å·¦å³èŠ‚ç‚¹ä¹Ÿæ˜¯å¯ä»¥æ’å…¥çš„
    this.q = append(this.q, node)
    return cur.Val
}

func (this *CBTInserter) Get_root() *TreeNode {
    return this.root
}
```

### [117.å¡«å……æ¯ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹æŒ‡é’ˆ II](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/description/)

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼š

```go
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

å¡«å……å®ƒçš„æ¯ä¸ª next æŒ‡é’ˆï¼Œè®©è¿™ä¸ªæŒ‡é’ˆæŒ‡å‘å…¶ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹ã€‚å¦‚æœæ‰¾ä¸åˆ°ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹ï¼Œåˆ™å°† next æŒ‡é’ˆè®¾ç½®ä¸º NULLã€‚

åˆå§‹çŠ¶æ€ä¸‹ï¼Œæ‰€æœ‰ next æŒ‡é’ˆéƒ½è¢«è®¾ç½®ä¸º NULLã€‚

ç¤ºä¾‹ 1ï¼š

![](https://chengzw258.oss-cn-beijing.aliyuncs.com/Article/202502102053686.png)

```go
è¾“å…¥ï¼šroot = [1,2,3,4,5,null,7]
è¾“å‡ºï¼š[1,#,2,3,#,4,5,7,#]
è§£é‡Šï¼šç»™å®šäºŒå‰æ ‘å¦‚å›¾ A æ‰€ç¤ºï¼Œä½ çš„å‡½æ•°åº”è¯¥å¡«å……å®ƒçš„æ¯ä¸ª next æŒ‡é’ˆï¼Œä»¥æŒ‡å‘å…¶ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹ï¼Œå¦‚å›¾ B æ‰€ç¤ºã€‚åºåˆ—åŒ–è¾“å‡ºæŒ‰å±‚åºéå†é¡ºåºï¼ˆç”± next æŒ‡é’ˆè¿æ¥ï¼‰ï¼Œ'#' è¡¨ç¤ºæ¯å±‚çš„æœ«å°¾ã€‚
```

è¿™é“é¢˜çš„ç›®æ ‡æ˜¯ **å¡«å……äºŒå‰æ ‘ä¸­æ¯ä¸ªèŠ‚ç‚¹çš„ `Next` æŒ‡é’ˆï¼Œä½¿å…¶æŒ‡å‘åŒä¸€å±‚çš„ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹**ï¼ˆå¦‚æœæ²¡æœ‰åˆ™æŒ‡å‘ `nil`ï¼‰ã€‚

**1. å±‚åºéå†**
- é‡‡ç”¨ **å¹¿åº¦ä¼˜å…ˆæœç´¢ (BFS)**ï¼Œä½¿ç”¨ **é˜Ÿåˆ— (`queue`)** é€å±‚éå†äºŒå‰æ ‘ã€‚
- æ¯æ¬¡å¤„ç†å½“å‰å±‚çš„æ‰€æœ‰èŠ‚ç‚¹ï¼Œå¹¶ç¡®ä¿ **æ¯ä¸ªèŠ‚ç‚¹çš„ `Next` æŒ‡å‘å®ƒå³ä¾§çš„èŠ‚ç‚¹**ã€‚

**2. å¤„ç† `Next` æŒ‡é’ˆ**
- è®¾å½“å‰å±‚çš„èŠ‚ç‚¹æ•°ä¸º `levelNum`ï¼Œéå† `i = 0` åˆ° `levelNum - 1`ï¼š
  - `cur` ä¸ºå½“å‰èŠ‚ç‚¹ã€‚
  - **è‹¥ `i < levelNum - 1`ï¼Œå³å½“å‰èŠ‚ç‚¹ä¸æ˜¯è¿™ä¸€å±‚çš„æœ€åä¸€ä¸ªèŠ‚ç‚¹ï¼Œåˆ™ä»¤ `cur.Next = queue[0]`**ï¼ˆå³é˜Ÿåˆ—ä¸­çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼‰ã€‚
  - è‹¥ `i == levelNum - 1`ï¼Œåˆ™ `cur.Next` é»˜è®¤ä¸º `nil`ï¼ˆæ— éœ€é¢å¤–æ“ä½œï¼‰ã€‚

**3. å…¥é˜Ÿä¸‹ä¸€å±‚èŠ‚ç‚¹**
- è‹¥ `cur` æœ‰ `Left` å­èŠ‚ç‚¹ï¼Œåˆ™å…¥é˜Ÿ `queue`ã€‚
- è‹¥ `cur` æœ‰ `Right` å­èŠ‚ç‚¹ï¼Œåˆ™å…¥é˜Ÿ `queue`ã€‚

**4. ç»ˆæ­¢æ¡ä»¶**
- `queue` ä¸ºç©ºæ—¶ï¼Œè¡¨ç¤ºæ‰€æœ‰èŠ‚ç‚¹çš„ `Next` æŒ‡é’ˆå·²æ­£ç¡®è¿æ¥ï¼Œè¿”å› `root`ã€‚

```go
func connect(root *Node) *Node {
    if root == nil {
        return nil // ç©ºæ ‘ç›´æ¥è¿”å›
    }
    
    // ä½¿ç”¨é˜Ÿåˆ—è¿›è¡Œå±‚åºéå†ï¼ˆBFSï¼‰
    queue := []*Node{root}
    
    for len(queue) > 0 {
        levelNum := len(queue) // è®°å½•å½“å‰å±‚çš„èŠ‚ç‚¹æ•°
        
        for i := 0; i < levelNum; i++ {
            cur := queue[0]  // å–å‡ºå½“å‰å±‚çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹
            queue = queue[1:] // ä»é˜Ÿåˆ—ä¸­ç§»é™¤è¯¥èŠ‚ç‚¹
            
            // è¿æ¥å½“å‰èŠ‚ç‚¹çš„ Next æŒ‡é’ˆåˆ°å³ä¾§ç›¸é‚»èŠ‚ç‚¹ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
            if i < levelNum-1 {
                cur.Next = queue[0] // å½“å‰èŠ‚ç‚¹æŒ‡å‘é˜Ÿåˆ—ä¸­çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼ˆå³åŒå±‚çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼‰
            }
            
            // å°†ä¸‹ä¸€å±‚çš„èŠ‚ç‚¹åŠ å…¥é˜Ÿåˆ—
            if cur.Left != nil {
                queue = append(queue, cur.Left)
            }
            if cur.Right != nil {
                queue = append(queue, cur.Right)
            }
        }
    }
    
    return root // è¿”å›ä¿®æ”¹åçš„æ ‘çš„æ ¹èŠ‚ç‚¹
}
```

### [662.äºŒå‰æ ‘æœ€å¤§å®½åº¦](https://leetcode.cn/problems/maximum-width-of-binary-tree/description/)

ç»™ä½ ä¸€æ£µäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ rootï¼Œè¿”å›æ ‘çš„æœ€å¤§å®½åº¦ã€‚

æ ‘çš„æœ€å¤§å®½åº¦æ˜¯æ‰€æœ‰å±‚ä¸­æœ€å¤§çš„å®½åº¦ã€‚

æ¯ä¸€å±‚çš„å®½åº¦è¢«å®šä¹‰ä¸ºè¯¥å±‚æœ€å·¦å’Œæœ€å³çš„éç©ºèŠ‚ç‚¹ï¼ˆå³ï¼Œä¸¤ä¸ªç«¯ç‚¹ï¼‰ä¹‹é—´çš„é•¿åº¦ã€‚å°†è¿™ä¸ªäºŒå‰æ ‘è§†ä½œä¸æ»¡äºŒå‰æ ‘ç»“æ„ç›¸åŒï¼Œä¸¤ç«¯ç‚¹é—´ä¼šå‡ºç°ä¸€äº›å»¶ä¼¸åˆ°è¿™ä¸€å±‚çš„ null èŠ‚ç‚¹ï¼Œè¿™äº› null èŠ‚ç‚¹ä¹Ÿè®¡å…¥é•¿åº¦ã€‚

ç¤ºä¾‹ 1ï¼š

![](https://chengzw258.oss-cn-beijing.aliyuncs.com/Article/202412082052080.png)

```go
è¾“å…¥ï¼šroot = [1,3,2,5,3,null,9]
è¾“å‡ºï¼š4
è§£é‡Šï¼šæœ€å¤§å®½åº¦å‡ºç°åœ¨æ ‘çš„ç¬¬ 3 å±‚ï¼Œå®½åº¦ä¸º 4 (5,3,null,9) ã€‚
```

æ ¸å¿ƒæ€è·¯ï¼š

- å±‚åºéå†ï¼šä½¿ç”¨é˜Ÿåˆ—æ¥éå†æ¯ä¸€å±‚èŠ‚ç‚¹ï¼ŒåŒæ—¶è®°å½•æ¯ä¸ªèŠ‚ç‚¹çš„ç´¢å¼•ã€‚
- å®Œå…¨äºŒå‰æ ‘ä¸­ï¼Œå·¦å­èŠ‚ç‚¹çš„ç´¢å¼•ä¸º **2 Ã— å½“å‰èŠ‚ç‚¹ç´¢å¼•**ã€‚å³å­èŠ‚ç‚¹çš„ç´¢å¼•ä¸º **2 Ã— å½“å‰èŠ‚ç‚¹ç´¢å¼• + 1**ã€‚
- è®¡ç®—æ¯å±‚å®½åº¦ï¼šæ¯å±‚å®½åº¦ä¸ºæœ€åä¸€ä¸ªèŠ‚ç‚¹ç´¢å¼•å‡å»ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ç´¢å¼•å†åŠ  1ã€‚

```go
type NodeIndex struct {
    Node  *TreeNode
    Index int
}

func widthOfBinaryTree(root *TreeNode) int {
    if root == nil {
        return 0
    }

   // ä½¿ç”¨é˜Ÿåˆ—ä¿å­˜èŠ‚ç‚¹å’Œå…¶ç´¢å¼•ï¼Œåˆå§‹ç´¢å¼•ä¸º 0
    queue := []NodeIndex{{Node: root, Index: 0}}
    maxWidth := 0

    for len(queue) > 0 {
        size := len(queue)
        
        // è®¡ç®—æ¯å±‚çš„å®½åº¦ï¼Œå¹¶ä¸æœ€å¤§å®½åº¦è¿›è¡Œæ¯”è¾ƒ
        levelStart, levelEnd := queue[0].Index, queue[len(queue)-1].Index
        maxWidth = max(maxWidth, levelEnd-levelStart+1)

        // éå†å½“å‰å±‚
        for i := 0; i < size; i++ {
            current := queue[0]
            queue = queue[1:]

            if current.Node.Left != nil {
                queue = append(queue, NodeIndex{Node: current.Node.Left, Index: 2 * current.Index})
            }
            if current.Node.Right != nil {
                queue = append(queue, NodeIndex{Node: current.Node.Right, Index: 2*current.Index + 1})
            }
        }
    }

    return maxWidth
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

### [863.äºŒå‰æ ‘ä¸­æ‰€æœ‰è·ç¦»ä¸º K çš„ç»“ç‚¹](https://leetcode.cn/problems/all-nodes-distance-k-in-binary-tree/description/)

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼ˆå…·æœ‰æ ¹ç»“ç‚¹ rootï¼‰ï¼Œä¸€ä¸ªç›®æ ‡ç»“ç‚¹ target ï¼Œå’Œä¸€ä¸ªæ•´æ•°å€¼ kï¼Œè¿”å›åˆ°ç›®æ ‡ç»“ç‚¹ target è·ç¦»ä¸º k çš„æ‰€æœ‰ç»“ç‚¹çš„å€¼çš„æ•°ç»„ã€‚

ç­”æ¡ˆå¯ä»¥ä»¥ä»»ä½•é¡ºåºè¿”å›ã€‚

ç¤ºä¾‹ 1ï¼š

![](https://chengzw258.oss-cn-beijing.aliyuncs.com/Article/202502102125318.png)


è¿™é“é¢˜çš„æ ¸å¿ƒæ€è·¯å¯ä»¥æ‹†è§£ä¸ºä¸¤ä¸ªæ­¥éª¤ï¼š

1. **éå†äºŒå‰æ ‘ï¼Œè®°å½•æ¯ä¸ªèŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹**ï¼ˆè½¬åŒ–æˆæ— å‘å›¾çš„ä¸€éƒ¨åˆ†ï¼‰
2. **BFS ä»¥ç›®æ ‡ `target` ä¸ºèµ·ç‚¹ï¼Œé€å±‚æ‰©å±•ï¼Œæ‰¾åˆ°æ‰€æœ‰è·ç¦» `k` çš„èŠ‚ç‚¹**

**æ­¥éª¤ 1ï¼šç”¨ DFS è®°å½•çˆ¶èŠ‚ç‚¹**
- **ä¸ºä»€ä¹ˆè¦è®°å½•çˆ¶èŠ‚ç‚¹ï¼Ÿ**
  - åœ¨äºŒå‰æ ‘ä¸­ï¼Œæ¯ä¸ªèŠ‚ç‚¹åªæœ‰ **å·¦å³å­èŠ‚ç‚¹**ï¼Œä½†æ²¡æœ‰æŒ‡å‘çˆ¶èŠ‚ç‚¹çš„æŒ‡é’ˆã€‚
  - **ä¸ºäº†èƒ½ä» `target` åå‘éå†çˆ¶èŠ‚ç‚¹**ï¼Œæˆ‘ä»¬æ‰‹åŠ¨ç»´æŠ¤ `parent` æ˜ å°„ï¼Œè®°å½•æ¯ä¸ªèŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ã€‚
  
- **å®ç°æ–¹å¼**
  - ä½¿ç”¨ DFS éå†æ•´æ£µæ ‘ï¼ŒæŠŠ `node.Val -> parentNode` å­˜åˆ° `parent` map é‡Œã€‚
  - è¿™æ ·æ¯ä¸ªèŠ‚ç‚¹å°±æœ‰äº†åŒå‘å…³ç³»ï¼Œå˜æˆä¸€ä¸ªæ— å‘å›¾ç»“æ„ï¼Œæ–¹ä¾¿ BFS éå†ã€‚

**æ­¥éª¤ 2ï¼šBFS éå† K å±‚**
- **BFS é€‚ç”¨äºå±‚çº§éå†**
  - BFS çš„æœ¬è´¨æ˜¯ã€Œé€å±‚æ‰©å±•ã€ï¼Œæˆ‘ä»¬ä» `target` å¼€å§‹æ‰©å±• `K` å±‚å³å¯ã€‚
  - éœ€è¦ä¸€ä¸ª **é˜Ÿåˆ— `q`**ï¼Œç”¨äºå­˜å‚¨å½“å‰å±‚çš„æ‰€æœ‰èŠ‚ç‚¹ã€‚
  - **æ¯ä¸€å±‚éå†æ—¶ï¼š**
    - æŠŠ **å½“å‰é˜Ÿåˆ— `q` é‡Œçš„æ‰€æœ‰èŠ‚ç‚¹** ä¾æ¬¡å–å‡ºã€‚
    - æŠŠ **æ‰€æœ‰æœªè®¿é—®çš„ç›¸é‚»èŠ‚ç‚¹ï¼ˆçˆ¶èŠ‚ç‚¹ã€å·¦å³å­èŠ‚ç‚¹ï¼‰åŠ å…¥ `q`**ã€‚
    - å¤„ç†å®Œå½“å‰å±‚åï¼Œ`dist++` è®°å½•å±‚æ•°ã€‚
  - **å½“ `dist == k` æ—¶ï¼Œé˜Ÿåˆ— `q` é‡Œçš„æ‰€æœ‰èŠ‚ç‚¹å°±æ˜¯ç­”æ¡ˆ**ã€‚

```go
func distanceK(root *TreeNode, target *TreeNode, k int) []int {
    // è®°å½•çˆ¶èŠ‚ç‚¹ï¼šnode.val -> parentNode
    // é¢˜ç›®è¯´äº†æ ‘ä¸­æ‰€æœ‰èŠ‚ç‚¹å€¼éƒ½æ˜¯å”¯ä¸€çš„ï¼Œæ‰€ä»¥å¯ä»¥ç”¨ node.val ä»£è¡¨ TreeNode
    parent := make(map[int]*TreeNode)
    
    // éå†æ‰€æœ‰èŠ‚ç‚¹ï¼Œè®°å½•æ¯ä¸ªèŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹
    traverse(root, nil, parent)

    // å¼€å§‹ä» target èŠ‚ç‚¹æ–½æ”¾ BFS ç®—æ³•ï¼Œæ‰¾åˆ°è·ç¦»ä¸º k çš„èŠ‚ç‚¹
    q := []*TreeNode{target}
    visited := make(map[int]bool)
    visited[target.Val] = true
    // è®°å½•ç¦» target çš„è·ç¦»
    dist := 0
    var res []int

    for len(q) > 0 {
        if dist == k {
            // æ‰¾åˆ°è·ç¦»èµ·ç‚¹ target è·ç¦»ä¸º k çš„èŠ‚ç‚¹
            for _, node := range q {
                res = append(res, node.Val)
            }
            return res
        }
        sz := len(q)
        for i := 0; i < sz; i++ {
            cur := q[0]
            q = q[1:]
            // å‘çˆ¶èŠ‚ç‚¹ã€å·¦å³å­èŠ‚ç‚¹æ‰©æ•£
            if parentNode, ok := parent[cur.Val]; ok && parentNode != nil && !visited[parentNode.Val] {
                visited[parentNode.Val] = true
                q = append(q, parentNode)
            }
            if cur.Left != nil && !visited[cur.Left.Val] {
                visited[cur.Left.Val] = true
                q = append(q, cur.Left)
            }
            if cur.Right != nil && !visited[cur.Right.Val] {
                visited[cur.Right.Val] = true
                q = append(q, cur.Right)
            }
        }
        // å‘å¤–æ‰©å±•ä¸€åœˆ
        dist++
    }

    return res
}

func traverse(root *TreeNode, parentNode *TreeNode, parent map[int]*TreeNode) {
    if root == nil {
        return
    }
    parent[root.Val] = parentNode
    // äºŒå‰æ ‘é€’å½’æ¡†æ¶
    traverse(root.Left, root, parent)
    traverse(root.Right, root, parent)
}
```

### [841.é’¥åŒ™å’Œæˆ¿é—´](https://leetcode.cn/problems/keys-and-rooms/description/)

æœ‰ n ä¸ªæˆ¿é—´ï¼Œæˆ¿é—´æŒ‰ä» 0 åˆ° n - 1 ç¼–å·ã€‚æœ€åˆï¼Œé™¤ 0 å·æˆ¿é—´å¤–çš„å…¶ä½™æ‰€æœ‰æˆ¿é—´éƒ½è¢«é”ä½ã€‚ä½ çš„ç›®æ ‡æ˜¯è¿›å…¥æ‰€æœ‰çš„æˆ¿é—´ã€‚ç„¶è€Œï¼Œä½ ä¸èƒ½åœ¨æ²¡æœ‰è·å¾—é’¥åŒ™çš„æ—¶å€™è¿›å…¥é”ä½çš„æˆ¿é—´ã€‚

å½“ä½ è¿›å…¥ä¸€ä¸ªæˆ¿é—´ï¼Œä½ å¯èƒ½ä¼šåœ¨é‡Œé¢æ‰¾åˆ°ä¸€å¥—ä¸åŒçš„é’¥åŒ™ï¼Œæ¯æŠŠé’¥åŒ™ä¸Šéƒ½æœ‰å¯¹åº”çš„æˆ¿é—´å·ï¼Œå³è¡¨ç¤ºé’¥åŒ™å¯ä»¥æ‰“å¼€çš„æˆ¿é—´ã€‚ä½ å¯ä»¥æ‹¿ä¸Šæ‰€æœ‰é’¥åŒ™å»è§£é”å…¶ä»–æˆ¿é—´ã€‚

ç»™ä½ ä¸€ä¸ªæ•°ç»„ rooms å…¶ä¸­ rooms[i] æ˜¯ä½ è¿›å…¥ i å·æˆ¿é—´å¯ä»¥è·å¾—çš„é’¥åŒ™é›†åˆã€‚å¦‚æœèƒ½è¿›å…¥æ‰€æœ‰æˆ¿é—´è¿”å› trueï¼Œå¦åˆ™è¿”å› falseã€‚

ç¤ºä¾‹ 1ï¼š

```go
è¾“å…¥ï¼šrooms = [[1],[2],[3],[]]
è¾“å‡ºï¼štrue
è§£é‡Šï¼š
æˆ‘ä»¬ä» 0 å·æˆ¿é—´å¼€å§‹ï¼Œæ‹¿åˆ°é’¥åŒ™ 1ã€‚
ä¹‹åæˆ‘ä»¬å» 1 å·æˆ¿é—´ï¼Œæ‹¿åˆ°é’¥åŒ™ 2ã€‚
ç„¶åæˆ‘ä»¬å» 2 å·æˆ¿é—´ï¼Œæ‹¿åˆ°é’¥åŒ™ 3ã€‚
æœ€åæˆ‘ä»¬å»äº† 3 å·æˆ¿é—´ã€‚
ç”±äºæˆ‘ä»¬èƒ½å¤Ÿè¿›å…¥æ¯ä¸ªæˆ¿é—´ï¼Œæˆ‘ä»¬è¿”å› trueã€‚
```

ç¤ºä¾‹ 2ï¼š

```go
è¾“å…¥ï¼šrooms = [[1,3],[3,0,1],[2],[0]]
è¾“å‡ºï¼šfalse
è§£é‡Šï¼šæˆ‘ä»¬ä¸èƒ½è¿›å…¥ 2 å·æˆ¿é—´ã€‚
```

è¿™é“é¢˜å¯ä»¥ç”¨ DFS æˆ–è€… BFS è§£å†³ï¼Œä»£ç å¦‚ä¸‹ï¼š

```go
// DFS è§£æ³•
func canVisitAllRooms(rooms [][]int) bool {
    n := len(rooms)
    visited := make([]bool, n)
    dfs(rooms, 0, visited)
    for _, v := range visited {
        if !v {
            return false
        }
    }
    return true
}

// å›¾çš„éå†æ¡†æ¶
func dfs(rooms [][]int, room int, visited []bool) {
    if visited[room] {
        return
    }
    // å‰åºä½ç½®ï¼Œæ ‡è®°æˆ¿é—´å·²è®¿é—®
    visited[room] = true

    for _, nextRoom := range rooms[room] {
        dfs(rooms, nextRoom, visited)
    }
}

// BFS è§£æ³•
func canVisitAllRooms2(rooms [][]int) bool {
    n := len(rooms)
    // è®°å½•è®¿é—®è¿‡çš„æˆ¿é—´
    visited := make([]bool, n)
    queue := []int{0}
    // åœ¨é˜Ÿåˆ—ä¸­åŠ å…¥èµ·ç‚¹ï¼Œå¯åŠ¨ BFS
    visited[0] = true

    for len(queue) > 0 {
        room := queue[0]
        queue = queue[1:]
        for _, nextRoom := range rooms[room] {
            if !visited[nextRoom] {
                visited[nextRoom] = true
                queue = append(queue, nextRoom)
            }
        }
    }

    for _, v := range visited {
        if !v {
            return false
        }
    }
    return true
}
```

### [1306.è·³è·ƒæ¸¸æˆ III](https://leetcode.cn/problems/jump-game-iii/description/)

è¿™é‡Œæœ‰ä¸€ä¸ªéè´Ÿæ•´æ•°æ•°ç»„ arrï¼Œä½ æœ€å¼€å§‹ä½äºè¯¥æ•°ç»„çš„èµ·å§‹ä¸‹æ ‡ start å¤„ã€‚å½“ä½ ä½äºä¸‹æ ‡ i å¤„æ—¶ï¼Œä½ å¯ä»¥è·³åˆ° `i + arr[i] æˆ–è€… i - arr[i]`ã€‚

è¯·ä½ åˆ¤æ–­è‡ªå·±æ˜¯å¦èƒ½å¤Ÿè·³åˆ°å¯¹åº”å…ƒç´ å€¼ä¸º 0 çš„ä»»ä¸€ä¸‹æ ‡å¤„ã€‚

æ³¨æ„ï¼Œä¸ç®¡æ˜¯ä»€ä¹ˆæƒ…å†µä¸‹ï¼Œä½ éƒ½æ— æ³•è·³åˆ°æ•°ç»„ä¹‹å¤–ã€‚

ç¤ºä¾‹ 1ï¼š

```go
è¾“å…¥ï¼šarr = [4,2,3,0,3,1,2], start = 5
è¾“å‡ºï¼štrue
è§£é‡Šï¼š
åˆ°è¾¾å€¼ä¸º 0 çš„ä¸‹æ ‡ 3 æœ‰ä»¥ä¸‹å¯èƒ½æ–¹æ¡ˆï¼š 
ä¸‹æ ‡ 5 -> ä¸‹æ ‡ 4 -> ä¸‹æ ‡ 1 -> ä¸‹æ ‡ 3 
ä¸‹æ ‡ 5 -> ä¸‹æ ‡ 6 -> ä¸‹æ ‡ 4 -> ä¸‹æ ‡ 1 -> ä¸‹æ ‡ 3
```

æ ¸å¿ƒæ€è·¯ï¼š

1. **ä½¿ç”¨ BFS è¿›è¡Œå±‚åºéå†**
   - æŠŠ `start` æ”¾å…¥é˜Ÿåˆ— `q` ä½œä¸ºæœç´¢çš„èµ·ç‚¹ã€‚
   - æ¯æ¬¡å–å‡ºé˜Ÿåˆ—ä¸­çš„å…ƒç´  `cur`ï¼Œå°è¯•è·³åˆ° `cur - arr[cur]`ï¼ˆå·¦ï¼‰å’Œ `cur + arr[cur]`ï¼ˆå³ï¼‰ã€‚
   - å¦‚æœ `arr[cur] == 0`ï¼Œè¯´æ˜æ‰¾åˆ°ç›®æ ‡ï¼Œè¿”å› `true`ã€‚

2. **ç”¨ `visited` æ•°ç»„é¿å…é‡å¤è®¿é—®**
   - é¿å…é™·å…¥æ­»å¾ªç¯ï¼ˆå¦‚ `[4,2,3,0,3,1,2]`ï¼Œ`arr[0] = 4`ï¼Œå¯èƒ½åå¤è·³ `0 â†’ 4 â†’ 0 â†’ 4`ï¼‰ã€‚
   - **æ¯è®¿é—®ä¸€ä¸ªæ–°ä½ç½®ï¼Œå°±æ ‡è®° `visited`ï¼Œé˜²æ­¢é‡å¤æœç´¢ã€‚**

3. **BFS ç»ˆæ­¢æ¡ä»¶**
   - **æ‰¾åˆ° `arr[i] == 0`ï¼Œç›´æ¥è¿”å› `true`**ã€‚
   - **é˜Ÿåˆ— `q` ä¸ºç©ºï¼Œè¡¨ç¤ºæ‰€æœ‰å¯è¾¾ä½ç½®éƒ½æœç´¢å®Œäº†ï¼Œä»ç„¶æ‰¾ä¸åˆ° `0`ï¼Œè¿”å› `false`ã€‚**

```go
func canReach(arr []int, start int) bool {
    visited := make([]bool, len(arr))
    q := []int{start}
    visited[start] = true
    // æ ‡å‡† BFS ç®—æ³•æ¡†æ¶
    for len(q) > 0 {
        cur := q[0]
        q = q[1:]
        if arr[cur] == 0 {
            return true
        }
        // å¾€å·¦è·³
        left := cur - arr[cur]
        if left >= 0 && !visited[left] {
            q = append(q, left)
            visited[left] = true
        }
        // å¾€å³è·³
        right := cur + arr[cur]
        if right < len(arr) && !visited[right] {
            q = append(q, right)
            visited[right] = true
        }
    }
    return false
}
```

### [433.æœ€å°åŸºå› å˜åŒ–](https://leetcode.cn/problems/minimum-genetic-mutation/description/)

åŸºå› åºåˆ—å¯ä»¥è¡¨ç¤ºä¸ºä¸€æ¡ç”± 8 ä¸ªå­—ç¬¦ç»„æˆçš„å­—ç¬¦ä¸²ï¼Œå…¶ä¸­æ¯ä¸ªå­—ç¬¦éƒ½æ˜¯ 'A'ã€'C'ã€'G' å’Œ 'T' ä¹‹ä¸€ã€‚

å‡è®¾æˆ‘ä»¬éœ€è¦è°ƒæŸ¥ä»åŸºå› åºåˆ— start å˜ä¸º end æ‰€å‘ç”Ÿçš„åŸºå› å˜åŒ–ã€‚ä¸€æ¬¡åŸºå› å˜åŒ–å°±æ„å‘³ç€è¿™ä¸ªåŸºå› åºåˆ—ä¸­çš„ä¸€ä¸ªå­—ç¬¦å‘ç”Ÿäº†å˜åŒ–ã€‚

ä¾‹å¦‚ï¼Œ"AACCGGTT" --> "AACCGGTA" å°±æ˜¯ä¸€æ¬¡åŸºå› å˜åŒ–ã€‚

å¦æœ‰ä¸€ä¸ªåŸºå› åº“ bank è®°å½•äº†æ‰€æœ‰æœ‰æ•ˆçš„åŸºå› å˜åŒ–ï¼Œåªæœ‰åŸºå› åº“ä¸­çš„åŸºå› æ‰æ˜¯æœ‰æ•ˆçš„åŸºå› åºåˆ—ã€‚ï¼ˆå˜åŒ–åçš„åŸºå› å¿…é¡»ä½äºåŸºå› åº“ bank ä¸­ï¼‰

ç»™ä½ ä¸¤ä¸ªåŸºå› åºåˆ— start å’Œ endï¼Œä»¥åŠä¸€ä¸ªåŸºå› åº“ bankï¼Œè¯·ä½ æ‰¾å‡ºå¹¶è¿”å›èƒ½å¤Ÿä½¿ start å˜åŒ–ä¸º end æ‰€éœ€çš„æœ€å°‘å˜åŒ–æ¬¡æ•°ã€‚å¦‚æœæ— æ³•å®Œæˆæ­¤åŸºå› å˜åŒ–ï¼Œè¿”å› -1ã€‚

æ³¨æ„ï¼šèµ·å§‹åŸºå› åºåˆ— start é»˜è®¤æ˜¯æœ‰æ•ˆçš„ï¼Œä½†æ˜¯å®ƒå¹¶ä¸ä¸€å®šä¼šå‡ºç°åœ¨åŸºå› åº“ä¸­ã€‚

ç¤ºä¾‹ 1ï¼š

```go
è¾“å…¥ï¼šstart = "AACCGGTT", end = "AACCGGTA", bank = ["AACCGGTA"]
è¾“å‡ºï¼š1
```

ç¤ºä¾‹ 2ï¼š

```go
è¾“å…¥ï¼šstart = "AACCGGTT", end = "AAACGGTA", bank = ["AACCGGTA","AACCGCTA","AAACGGTA"]
è¾“å‡ºï¼š2
```

ç¤ºä¾‹ 3ï¼š

```go
è¾“å…¥ï¼šstart = "AAAAACCC", end = "AACCCCCC", bank = ["AAAACCCC","AAACCCCC","AACCCCCC"]
è¾“å‡ºï¼š3
```

æ ¸å¿ƒæ€è·¯ï¼š

1. **æ„å»ºåŸºå› åº“é›†åˆ (`bankSet`)**  
   - ä½¿ç”¨ `map[string]struct{}` å­˜å‚¨ `bank` ä¸­çš„åŸºå› ï¼Œæé«˜æŸ¥è¯¢æ•ˆç‡ (`O(1)`)ã€‚
   - å¦‚æœ `endGene` ä¸åœ¨ `bankSet` ä¸­ï¼Œåˆ™ç›´æ¥è¿”å› `-1`ï¼Œå› ä¸ºæ— æ³•å˜å¼‚åˆ°ç›®æ ‡åŸºå› ã€‚

2. **å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ˆBFSï¼‰æ±‚æœ€çŸ­è·¯å¾„**  
   - **åˆå§‹åŒ–é˜Ÿåˆ—** (`q`)ï¼Œå°† `startGene` ä½œä¸ºèµ·ç‚¹ï¼Œå¹¶æ ‡è®°ä¸ºè®¿é—®è¿‡ (`visited`)ã€‚
   - **é€å±‚æ‰©å±•**ï¼Œæ¯æ¬¡éå†å½“å‰é˜Ÿåˆ—ä¸­çš„æ‰€æœ‰åŸºå› ï¼š
     - å¦‚æœå½“å‰åŸºå›  `cur` ç­‰äº `endGene`ï¼Œè¿”å›å½“å‰æ­¥æ•° `step`ã€‚
     - è®¡ç®— `cur` çš„æ‰€æœ‰å¯èƒ½å˜å¼‚ (`getAllMutation`)ï¼Œå¦‚æœæ–°åŸºå› åœ¨ `bankSet` ä¸­ä¸”æœªè®¿é—®ï¼Œåˆ™åŠ å…¥é˜Ÿåˆ—å¹¶æ ‡è®°å·²è®¿é—®ã€‚
   - **æ­¥æ•°ç´¯åŠ **ï¼Œæ¯éå†å®Œä¸€å±‚ï¼Œæ­¥æ•° `step++`ï¼Œç›´åˆ°é˜Ÿåˆ—ä¸ºç©ºä»æœªæ‰¾åˆ° `endGene`ï¼Œåˆ™è¿”å› `-1`ã€‚

3. **è®¡ç®—æ‰€æœ‰å¯èƒ½çš„å˜å¼‚ (`getAllMutation`)**  
   - éå† `gene` çš„æ¯ä¸ªä½ç½®ï¼Œå°è¯•ç”¨ `A/G/C/T` æ›¿æ¢åŸå­—ç¬¦ï¼Œç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„å˜å¼‚åŸºå› ã€‚
   - è¿‡æ»¤æ‰ `startGene` æœ¬èº«ï¼ˆå³å˜å¼‚å­—ç¬¦ä¸èƒ½å’ŒåŸå­—ç¬¦ç›¸åŒï¼‰ã€‚
   - è¿”å›æ‰€æœ‰å¯èƒ½çš„æ–°åŸºå› åˆ—è¡¨ï¼Œç”¨äº BFS è¿›ä¸€æ­¥æ‰©å±•ã€‚


```go
func minMutation(startGene string, endGene string, bank []string) int {
    // ä½¿ç”¨ map å­˜å‚¨ bank ä¸­çš„åŸºå› ï¼Œæ–¹ä¾¿æ ¹æ®åŸºå› åˆ¤æ–­æ˜¯å¦å­˜åœ¨
    bankSet := make(map[string]struct{})
    for _, gene := range bank {
        bankSet[gene] = struct{}{}
    }
    if _, exists := bankSet[endGene]; !exists {
        return -1
    }

    // BFS æ ‡å‡†æ¡†æ¶
    q := []string{startGene}
    visited := make(map[string]bool)
    visited[startGene] = true
    step := 0
    for len(q) > 0 {
        sz := len(q)
        for j := 0; j < sz; j++ {
            cur := q[0]
            q = q[1:]
            if cur == endGene {
                return step
            }
            // å‘å‘¨å›´æ‰©æ•£
            for _, newGene := range getAllMutation(cur) {
                if _, seen := visited[newGene]; !seen {
                    if _, valid := bankSet[newGene]; valid {
                        q = append(q, newGene)
                        visited[newGene] = true
                    }
                }
            }
        }
        step++
    }
    return -1
}

// å½“å‰åŸºå› çš„æ¯ä¸ªä½ç½®éƒ½å¯ä»¥å˜å¼‚ä¸º A/G/C/Tï¼Œç©·ä¸¾æ‰€æœ‰å¯èƒ½çš„ç»“æ„
func getAllMutation(gene string) []string {
    res := []string{}
    geneChars := []rune(gene)
    for i := 0; i < len(geneChars); i++ {
        oldChar := geneChars[i]
        for _, newChar := range []rune{'A', 'G', 'C', 'T'} {
            if newChar != oldChar {
                geneChars[i] = newChar
                res = append(res, string(geneChars))
            }
        }
        // æ¢å¤åŸå§‹åŸºå› å­—ç¬¦ä¸²ï¼Œé˜²æ­¢å½±å“åç»­çš„å˜å¼‚è®¡ç®—
        geneChars[i] = oldChar
    }
    return res
}
```

### [1926.è¿·å®«ä¸­ç¦»å…¥å£æœ€è¿‘çš„å‡ºå£](https://leetcode.cn/problems/nearest-exit-from-entrance-in-maze/description/)

ç»™ä½ ä¸€ä¸ª m x n çš„è¿·å®«çŸ©é˜µ mazeï¼ˆä¸‹æ ‡ä» 0 å¼€å§‹ï¼‰ï¼ŒçŸ©é˜µä¸­æœ‰ç©ºæ ¼å­ï¼ˆç”¨ '.' è¡¨ç¤ºï¼‰å’Œå¢™ï¼ˆç”¨ '+' è¡¨ç¤ºï¼‰ã€‚åŒæ—¶ç»™ä½ è¿·å®«çš„å…¥å£ entranceï¼Œç”¨ `entrance = [entrancerow, entrancecol]` è¡¨ç¤ºä½ ä¸€å¼€å§‹æ‰€åœ¨æ ¼å­çš„è¡Œå’Œåˆ—ã€‚

æ¯ä¸€æ­¥æ“ä½œï¼Œä½ å¯ä»¥å¾€ä¸Šï¼Œä¸‹ï¼Œå·¦æˆ–è€…å³ç§»åŠ¨ä¸€ä¸ªæ ¼å­ã€‚ä½ ä¸èƒ½è¿›å…¥å¢™æ‰€åœ¨çš„æ ¼å­ï¼Œä½ ä¹Ÿä¸èƒ½ç¦»å¼€è¿·å®«ã€‚ä½ çš„ç›®æ ‡æ˜¯æ‰¾åˆ°ç¦» entrance æœ€è¿‘çš„å‡ºå£ã€‚å‡ºå£çš„å«ä¹‰æ˜¯ maze è¾¹ç•Œä¸Šçš„ç©ºæ ¼å­ã€‚entrance æ ¼å­ä¸ç®—å‡ºå£ã€‚

è¯·ä½ è¿”å›ä» entrance åˆ°æœ€è¿‘å‡ºå£çš„æœ€çŸ­è·¯å¾„çš„æ­¥æ•° ï¼Œå¦‚æœä¸å­˜åœ¨è¿™æ ·çš„è·¯å¾„ï¼Œè¯·ä½ è¿”å› -1ã€‚

**æ ¸å¿ƒæ€è·¯**ï¼š
1. **ä½¿ç”¨ BFS è¿›è¡Œæœ€çŸ­è·¯å¾„æœç´¢**
   - è¿·å®«æ˜¯ **ç½‘æ ¼ï¼ˆäºŒç»´æ•°ç»„ï¼‰**ï¼Œä» `entrance` å¼€å§‹ï¼Œå¯»æ‰¾ **æœ€è¿‘çš„å‡ºå£**ã€‚
   - **BFS é€‚ç”¨äºæœ€çŸ­è·¯å¾„é—®é¢˜**ï¼Œå› ä¸ºå®ƒé€å±‚æ‰©å±•ï¼Œæœ€æ—©åˆ°è¾¾çš„å‡ºå£å¿…ç„¶æ˜¯æœ€çŸ­è·¯å¾„ã€‚

2. **å¦‚ä½•åˆ¤æ–­å‡ºå£ï¼Ÿ**
   - è¿·å®«å‡ºå£å¿…é¡»æ˜¯**è¾¹ç•Œä¸Šçš„ `.`**ã€‚
   - **ä¸èƒ½æ˜¯ `entrance` æœ¬èº«**ï¼ˆå³ `entrance` ä¸èƒ½ç®—ä½œå‡ºå£ï¼‰ã€‚

3. **BFS éå†æ–¹å¼**
   - **åˆå§‹åŒ– BFS é˜Ÿåˆ—**ï¼Œä» `entrance` å¼€å§‹ã€‚
   - **æ¯æ¬¡ä»é˜Ÿåˆ—å–å‡ºä¸€ä¸ªä½ç½®**ï¼Œå°è¯•å‘ **ä¸Šã€ä¸‹ã€å·¦ã€å³** å››ä¸ªæ–¹å‘æ‰©å±•ã€‚
   - **é‡åˆ°å‡ºå£ç«‹å³è¿”å›å½“å‰æ­¥æ•°**ï¼Œå› ä¸º BFS å…ˆæ‰¾åˆ°çš„ä¸€å®šæ˜¯æœ€è¿‘çš„å‡ºå£ã€‚

4. **é¿å…é‡å¤è®¿é—®**
   - ç”¨ **`visited` æ•°ç»„** è®°å½•å·²è®¿é—®ä½ç½®ï¼Œé˜²æ­¢æ­»å¾ªç¯ã€‚

```go
// BFS ç®—æ³•çš„é˜Ÿåˆ—å’Œ visited æ•°ç»„
func nearestExit(maze [][]byte, entrance []int) int {
    m := len(maze)
    n := len(maze[0])
    dirs := [][]int{{0, 1}, {0, -1}, {1, 0}, {-1, 0}}
    
    queue := make([][]int, 0)
    visited := make([][]bool, m)
    for i := range visited {
        visited[i] = make([]bool, n)
    }
    
    queue = append(queue, entrance)
    visited[entrance[0]][entrance[1]] = true
    
    // å¯åŠ¨ BFS ç®—æ³•ä» entrance å¼€å§‹åƒå››å‘¨æ‰©æ•£
    step := 0
    for len(queue) > 0 {
        sz := len(queue)
        step++
        // æ‰©æ•£å½“å‰é˜Ÿåˆ—ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹
        for i := 0; i < sz; i++ {
            cur := queue[0]
            queue = queue[1:]
            // æ¯ä¸ªèŠ‚ç‚¹éƒ½ä¼šå°è¯•å‘ä¸Šä¸‹å·¦å³å››ä¸ªæ–¹å‘æ‰©å±•ä¸€æ­¥
            for _, dir := range dirs {
                x := cur[0] + dir[0]
                y := cur[1] + dir[1]
                if x < 0 || x >= m || y < 0 || y >= n || visited[x][y] || maze[x][y] == '+' {
                    continue
                }
                if x == 0 || x == m-1 || y == 0 || y == n-1 {
                    // èµ°åˆ°è¾¹ç•Œï¼ˆå‡ºå£ï¼‰
                    return step
                }
                visited[x][y] = true
                queue = append(queue, []int{x, y})
            }
        }
    }
    return -1
}
```

### [1091.äºŒè¿›åˆ¶çŸ©é˜µä¸­çš„æœ€çŸ­è·¯å¾„](https://leetcode.cn/problems/shortest-path-in-binary-matrix/description/)

ç»™ä½ ä¸€ä¸ª n x n çš„äºŒè¿›åˆ¶çŸ©é˜µ grid ä¸­ï¼Œè¿”å›çŸ©é˜µä¸­æœ€çŸ­ç•…é€šè·¯å¾„çš„é•¿åº¦ã€‚å¦‚æœä¸å­˜åœ¨è¿™æ ·çš„è·¯å¾„ï¼Œè¿”å› -1ã€‚

äºŒè¿›åˆ¶çŸ©é˜µä¸­çš„ç•…é€šè·¯å¾„æ˜¯ä¸€æ¡ä»å·¦ä¸Šè§’å•å…ƒæ ¼ï¼ˆå³ï¼Œ(0, 0)ï¼‰åˆ°å³ä¸‹è§’å•å…ƒæ ¼ï¼ˆå³ï¼Œ(n - 1, n - 1)ï¼‰çš„è·¯å¾„ï¼Œè¯¥è·¯å¾„åŒæ—¶æ»¡è¶³ä¸‹è¿°è¦æ±‚ï¼š

- è·¯å¾„é€”ç»çš„æ‰€æœ‰å•å…ƒæ ¼çš„å€¼éƒ½æ˜¯ 0ã€‚
- è·¯å¾„ä¸­æ‰€æœ‰ç›¸é‚»çš„å•å…ƒæ ¼åº”å½“åœ¨ 8 ä¸ªæ–¹å‘ä¹‹ä¸€ä¸Šè¿é€šï¼ˆå³ï¼Œç›¸é‚»ä¸¤å•å…ƒä¹‹é—´å½¼æ­¤ä¸åŒä¸”å…±äº«ä¸€æ¡è¾¹æˆ–è€…ä¸€ä¸ªè§’ï¼‰ã€‚
- ç•…é€šè·¯å¾„çš„é•¿åº¦ æ˜¯è¯¥è·¯å¾„é€”ç»çš„å•å…ƒæ ¼æ€»æ•°ã€‚

ç¤ºä¾‹ 1ï¼š

![](https://chengzw258.oss-cn-beijing.aliyuncs.com/Article/202502111113375.png)

```go
è¾“å…¥ï¼šgrid = [[0,1],[1,0]]
è¾“å‡ºï¼š2
```

ç¤ºä¾‹ 2ï¼š

![](https://chengzw258.oss-cn-beijing.aliyuncs.com/Article/202502111113286.png)

```go
è¾“å…¥ï¼šgrid = [[0,0,0],[1,1,0],[1,1,0]]
è¾“å‡ºï¼š4
```

ç¤ºä¾‹ 3ï¼š

```go
è¾“å…¥ï¼šgrid = [[1,0,0],[1,1,0],[1,1,0]]
è¾“å‡ºï¼š-1
```

**æ ¸å¿ƒæ€è·¯**ï¼š
1. **ä½¿ç”¨ BFSï¼ˆå¹¿åº¦ä¼˜å…ˆæœç´¢ï¼‰æ‰¾æœ€çŸ­è·¯å¾„**  
   - ç”±äºæ¯æ¬¡åªèƒ½èµ°åˆ°ç›¸é‚»çš„ `0`ï¼Œå¹¶ä¸”è·¯å¾„çš„æ­¥æ•°æ˜¯å•ä½æ­¥é•¿ï¼Œä½¿ç”¨ **BFS** å¯ä»¥ä¿è¯æ‰¾åˆ°çš„è·¯å¾„æ˜¯æœ€çŸ­çš„ã€‚

2. **ç‰¹æ®Šæƒ…å†µåˆ¤æ–­**
   - **å¦‚æœèµ·ç‚¹ `(0,0)` æˆ– ç»ˆç‚¹ `(m-1,n-1)` æ˜¯ `1`ï¼ˆéšœç¢ç‰©ï¼‰ï¼Œç›´æ¥è¿”å› `-1`**ï¼Œå› ä¸ºæ— æ³•å‡ºå‘æˆ–æ— æ³•æŠµè¾¾ã€‚

3. **BFS è¿‡ç¨‹**
   - **åˆå§‹åŒ– BFS é˜Ÿåˆ—**ï¼Œä»èµ·ç‚¹ `(0,0)` å¼€å§‹ï¼Œå¹¶æ ‡è®°å·²è®¿é—®ã€‚
   - **é€å±‚æ‰©å±•**ï¼Œæ¯æ¬¡ä» `queue` å–å‡ºå½“å‰å±‚çš„æ‰€æœ‰èŠ‚ç‚¹ï¼Œå‘ **8 ä¸ªæ–¹å‘** æ‰©å±•ã€‚
   - **å¦‚æœæŸä¸ªèŠ‚ç‚¹ `(m-1, n-1)` è¢«è®¿é—®åˆ°ï¼Œç«‹å³è¿”å›å½“å‰æ­¥æ•°**ï¼Œå› ä¸º BFS ä¿è¯æœ€æ—©åˆ°è¾¾çš„è·¯å¾„æ˜¯æœ€çŸ­è·¯å¾„ã€‚

4. **è®¿é—®æ§åˆ¶**
   - **ä½¿ç”¨ `visited` æ•°ç»„** è®°å½•è®¿é—®è¿‡çš„èŠ‚ç‚¹ï¼Œé¿å…é‡å¤è®¿é—®ã€‚
   - **è¾¹ç•Œæ£€æŸ¥**ï¼Œç¡®ä¿æ–°çš„åæ ‡åœ¨ `grid` èŒƒå›´å†…ï¼Œä¸”æ˜¯ `0`ï¼ˆå¯èµ°è·¯å¾„ï¼‰ã€‚

5. **æ— æ³•åˆ°è¾¾ç›®æ ‡**
   - **å¦‚æœ BFS ç»“æŸåä»ç„¶æ²¡æœ‰è®¿é—®åˆ°ç»ˆç‚¹ï¼Œè¿”å› `-1`**ï¼Œè¡¨ç¤ºæ— æ³•æ‰¾åˆ°é€šå¾€ç»ˆç‚¹çš„è·¯å¾„ã€‚

```go
func shortestPathBinaryMatrix(grid [][]int) int {
    m, n := len(grid), len(grid[0]) // è·å–ç½‘æ ¼çš„è¡Œæ•°å’Œåˆ—æ•°
    
    // å¦‚æœèµ·ç‚¹ (0,0) æˆ–ç»ˆç‚¹ (m-1,n-1) æ˜¯éšœç¢ç‰©ï¼Œæ— æ³•é€šè¡Œï¼Œç›´æ¥è¿”å› -1
    if grid[0][0] == 1 || grid[m-1][n-1] == 1 {
        return -1
    }

    // è®°å½•è®¿é—®è¿‡çš„æ ¼å­ï¼Œé˜²æ­¢é‡å¤æœç´¢
    visited := make([][]bool, m)
    for i := range visited {
        visited[i] = make([]bool, n)
    }

    // 8 ä¸ªæ–¹å‘çš„ç§»åŠ¨æ–¹å¼ï¼ˆä¸Šä¸‹å·¦å³+å››ä¸ªå¯¹è§’çº¿ï¼‰
    dirs := [][]int{
        {0, 1},  {0, -1},  {1, 0},  {-1, 0}, 
        {1, 1},  {1, -1},  {-1, 1}, {-1, -1},
    }

    // BFS é˜Ÿåˆ—åˆå§‹åŒ–ï¼Œå­˜å‚¨ {x, y} ä½ç½®
    queue := make([][]int, 0)
    queue = append(queue, []int{0, 0}) // å°†èµ·ç‚¹ (0,0) å…¥é˜Ÿ
    visited[0][0] = true // æ ‡è®°èµ·ç‚¹å·²è®¿é—®

    step := 1 // è®°å½•å½“å‰çš„æ­¥æ•°ï¼Œä» 1 å¼€å§‹ï¼ˆå› ä¸ºèµ·ç‚¹æœ¬èº«ç®—ä¸€æ­¥ï¼‰
    
    // å¼€å§‹ BFS æœç´¢
    for len(queue) > 0 {
        sz := len(queue) // å½“å‰å±‚çš„èŠ‚ç‚¹æ•°
        
        // éå†å½“å‰å±‚çš„æ‰€æœ‰èŠ‚ç‚¹
        for i := 0; i < sz; i++ {
            cur := queue[0]   // å–å‡ºé˜Ÿåˆ—å¤´éƒ¨çš„èŠ‚ç‚¹
            queue = queue[1:] // å‡ºé˜Ÿåˆ—

            x, y := cur[0], cur[1] // å½“å‰æ‰€åœ¨ä½ç½®

            // å¦‚æœåˆ°è¾¾ç»ˆç‚¹ (m-1, n-1)ï¼Œè¿”å›æ­¥æ•°
            if x == m-1 && y == n-1 {
                return step
            }

            // éå† 8 ä¸ªæ–¹å‘ï¼Œæ‰©å±•ä¸‹ä¸€å±‚
            for _, dir := range dirs {
                nextX := x + dir[0]
                nextY := y + dir[1]

                // è¾¹ç•Œæ£€æŸ¥ + æœªè®¿é—® + ä¸èƒ½æ˜¯éšœç¢ç‰©
                if nextX < 0 || nextX >= m || nextY < 0 || nextY >= n || visited[nextX][nextY] || grid[nextX][nextY] == 1 {
                    continue
                }

                // æ ‡è®°è¯¥ä½ç½®å·²è®¿é—®ï¼Œå¹¶åŠ å…¥é˜Ÿåˆ—
                visited[nextX][nextY] = true
                queue = append(queue, []int{nextX, nextY})
            }
        }
        step++ // æ¯éå†å®Œä¸€å±‚ï¼Œæ­¥æ•°åŠ ä¸€
    }

    // å¦‚æœ BFS ç»“æŸåä»ç„¶æ²¡æœ‰åˆ°è¾¾ç»ˆç‚¹ï¼Œè¿”å› -1
    return -1
}
```

### [310.æœ€å°é«˜åº¦æ ‘](https://leetcode.cn/problems/minimum-height-trees/description/)

æ ‘æ˜¯ä¸€ä¸ªæ— å‘å›¾ï¼Œå…¶ä¸­ä»»ä½•ä¸¤ä¸ªé¡¶ç‚¹åªé€šè¿‡ä¸€æ¡è·¯å¾„è¿æ¥ã€‚æ¢å¥è¯è¯´ï¼Œä»»ä½•ä¸€ä¸ªæ²¡æœ‰ç®€å•ç¯è·¯çš„è¿é€šå›¾éƒ½æ˜¯ä¸€æ£µæ ‘ã€‚

ç»™ä½ ä¸€æ£µåŒ…å« n ä¸ªèŠ‚ç‚¹çš„æ ‘ï¼Œæ ‡è®°ä¸º 0 åˆ° n - 1ã€‚ç»™å®šæ•°å­— n å’Œä¸€ä¸ªæœ‰ n - 1 æ¡æ— å‘è¾¹çš„ edges åˆ—è¡¨ï¼ˆæ¯ä¸€ä¸ªè¾¹éƒ½æ˜¯ä¸€å¯¹æ ‡ç­¾ï¼‰ï¼Œå…¶ä¸­ edges[i] = [ai, bi] è¡¨ç¤ºæ ‘ä¸­èŠ‚ç‚¹ ai å’Œ bi ä¹‹é—´å­˜åœ¨ä¸€æ¡æ— å‘è¾¹ã€‚

å¯é€‰æ‹©æ ‘ä¸­ä»»ä½•ä¸€ä¸ªèŠ‚ç‚¹ä½œä¸ºæ ¹ã€‚å½“é€‰æ‹©èŠ‚ç‚¹ x ä½œä¸ºæ ¹èŠ‚ç‚¹æ—¶ï¼Œè®¾ç»“æœæ ‘çš„é«˜åº¦ä¸º hã€‚åœ¨æ‰€æœ‰å¯èƒ½çš„æ ‘ä¸­ï¼Œå…·æœ‰æœ€å°é«˜åº¦çš„æ ‘ï¼ˆå³ï¼Œmin(h)ï¼‰è¢«ç§°ä¸ºæœ€å°é«˜åº¦æ ‘ã€‚

è¯·ä½ æ‰¾åˆ°æ‰€æœ‰çš„æœ€å°é«˜åº¦æ ‘å¹¶æŒ‰ä»»æ„é¡ºåº è¿”å›å®ƒä»¬çš„æ ¹èŠ‚ç‚¹æ ‡ç­¾åˆ—è¡¨ã€‚

æ ‘çš„é«˜åº¦æ˜¯æŒ‡æ ¹èŠ‚ç‚¹å’Œå¶å­èŠ‚ç‚¹ä¹‹é—´æœ€é•¿å‘ä¸‹è·¯å¾„ä¸Šè¾¹çš„æ•°é‡ã€‚

ç¤ºä¾‹ 1ï¼š

![](https://chengzw258.oss-cn-beijing.aliyuncs.com/Article/202502111151963.png)

```go
è¾“å…¥ï¼šn = 4, edges = [[1,0],[1,2],[1,3]]
è¾“å‡ºï¼š[1]
è§£é‡Šï¼šå¦‚å›¾æ‰€ç¤ºï¼Œå½“æ ¹æ˜¯æ ‡ç­¾ä¸º 1 çš„èŠ‚ç‚¹æ—¶ï¼Œæ ‘çš„é«˜åº¦æ˜¯ 1 ï¼Œè¿™æ˜¯å”¯ä¸€çš„æœ€å°é«˜åº¦æ ‘ã€‚
```

ç¤ºä¾‹ 2ï¼š

![](https://chengzw258.oss-cn-beijing.aliyuncs.com/Article/202502111152509.png)

```go
è¾“å…¥ï¼šn = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]]
è¾“å‡ºï¼š[3,4]
```

æ ¸å¿ƒæ€è·¯ï¼š

- 1. é¦–å…ˆï¼Œæˆ‘ä»¬æŠŠé¢˜ç›®è¾“å…¥çš„ edges è½¬æ¢æˆé‚»æ¥è¡¨ã€‚
- 2. ç„¶åï¼Œæˆ‘ä»¬ä»å¶å­èŠ‚ç‚¹å¼€å§‹ï¼Œä¸€å±‚ä¸€å±‚åœ°åˆ é™¤å¶å­èŠ‚ç‚¹ï¼ˆæ¯åˆ é™¤ä¸€å±‚å¶å­èŠ‚ç‚¹ï¼Œå°±ä¼šäº§ç”Ÿæ–°çš„å¶å­èŠ‚ç‚¹ï¼‰ï¼Œç›´åˆ°å‰©ä¸‹çš„èŠ‚ç‚¹æ•°å°äºç­‰äº 2 ä¸ªä¸ºæ­¢ã€‚ä¹‹æ‰€ä»¥æ˜¯ 2 ä¸ªè€Œä¸æ˜¯ 1 ä¸ªï¼Œæ˜¯å› ä¸ºå¦‚æœè¾“å…¥çš„è¿™å¹…å›¾ä¸¤è¾¹å®Œå…¨å¯¹ç§°ï¼Œå¯èƒ½å‡ºç°ä¸¤ä¸ªèŠ‚ç‚¹éƒ½å¯ä»¥ä½œä¸ºæ ¹èŠ‚ç‚¹çš„æƒ…å†µã€‚

![](https://chengzw258.oss-cn-beijing.aliyuncs.com/Article/202502111213729.png)

- 3.æœ€åå‰©ä¸‹çš„è¿™äº›èŠ‚ç‚¹ï¼Œå°±æ˜¯æˆ‘ä»¬è¦æ‰¾çš„æœ€å°é«˜åº¦æ ‘çš„æ ¹èŠ‚ç‚¹ã€‚

```go
func findMinHeightTrees(n int, edges [][]int) []int {
    if n == 1 {
        // base caseï¼Œåªæœ‰ä¸€ä¸ªèŠ‚ç‚¹ 0 çš„è¯ï¼Œæ— æ³•å½¢æˆè¾¹ï¼Œæ‰€ä»¥ç›´æ¥è¿”å›èŠ‚ç‚¹ 0
        return []int{0}
    }

    // 1ã€æ„å»ºé‚»æ¥è¡¨
    graph := make([][]int, n)
    for i := 0; i < n; i++ {
        graph[i] = []int{}
    }
    for _, edge := range edges {
        // æ— å‘å›¾ï¼Œç­‰åŒäºåŒå‘å›¾
        graph[edge[0]] = append(graph[edge[0]], edge[1])
        graph[edge[1]] = append(graph[edge[1]], edge[0])
    }

    // 2ã€æ‰¾åˆ°æ‰€æœ‰çš„å¶å­èŠ‚ç‚¹
    q := []int{}
    for i := 0; i < n; i++ {
        if len(graph[i]) == 1 {
            q = append(q, i)
        }
    }

    // 3ã€ä¸æ–­åˆ é™¤å¶å­èŠ‚ç‚¹ï¼Œç›´åˆ°å‰©ä¸‹çš„èŠ‚ç‚¹æ•°å°äºç­‰äº 2 ä¸ª
    nodeCount := n
    for nodeCount > 2 {
        sz := len(q)
        nodeCount -= sz
        newQ := []int{}
        for i := 0; i < sz; i++ {
            // åˆ é™¤å½“å‰å¶å­èŠ‚ç‚¹
            cur := q[i]

            // æ‰¾åˆ°ä¸å½“å‰å¶å­èŠ‚ç‚¹ç›¸è¿çš„èŠ‚ç‚¹
            for _, neighbor := range graph[cur] {
                // å°†è¢«åˆ é™¤çš„å¶å­èŠ‚ç‚¹çš„é‚»æ¥èŠ‚ç‚¹çš„åº¦å‡ 1
                for j, val := range graph[neighbor] {
                    if val == cur {
                        graph[neighbor] = append(graph[neighbor][:j], graph[neighbor][j+1:]...)
                    }
                }

                // å¦‚æœåˆ é™¤åï¼Œç›¸è¿èŠ‚ç‚¹çš„åº¦ä¸º 1ï¼Œè¯´æ˜å®ƒä¹Ÿå˜æˆäº†å¶å­èŠ‚ç‚¹
                if len(graph[neighbor]) == 1 {
                    newQ = append(newQ, neighbor)
                }
            }
        }
        q = newQ
    }

    // 4ã€æœ€åå‰©ä¸‹çš„èŠ‚ç‚¹å°±æ˜¯æ ¹èŠ‚ç‚¹
    return q
}
```

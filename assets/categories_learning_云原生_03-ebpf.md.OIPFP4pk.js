import{_ as e,o as r,c as t,R as a}from"./chunks/framework.FHZ5yb6k.js";const u=JSON.parse('{"title":"eBPF","description":"","frontmatter":{"title":"eBPF","author":"Se7en","categories":["eBPF"],"tags":["eBPF"]},"headers":[],"relativePath":"categories/learning/云原生/03-ebpf.md","filePath":"categories/learning/云原生/03-ebpf.md","lastUpdated":1733218082000}'),o={name:"categories/learning/云原生/03-ebpf.md"},i=a('<h2 id="core-compile-once-–-run-everywhere" tabindex="-1">CORE（Compile Once – Run Everywhere） <a class="header-anchor" href="#core-compile-once-–-run-everywhere" aria-label="Permalink to &quot;CORE（Compile Once – Run Everywhere）&quot;">​</a></h2><p><img src="https://chengzw258.oss-cn-beijing.aliyuncs.com/Article/202412022206044.png" alt=""></p><p>由于 vmlinux.h 文件是由当前运行内核生成的，如果你试图将编译好的 eBPF 程序在另一台运行不同内核版本的机器上运行，可能会面临崩溃的窘境。这主要是因为在不同的版本中，对应数据类型的定义可能会在 Linux 源代码中发生变化。</p><p>但是，通过使用 libbpf 库提供的功能可以实现 “CO:RE”（一次编译，到处运行）。libbpf 库定义了部分宏（比如 BPF_CORE_READ），其可分析 eBPF 程序试图访问 vmlinux.h 中定义的类型中的哪些字段。如果访问的字段在当前内核定义的结构中发生了移动，宏 / 辅助函数会协助自动找到对应字段【译者注：对于可能消失的字段，也提供了对应的辅助函数 bpf_core_field_exists】。因此，我们可以使用当前内核中生成的 vmlinux.h 头文件来编译 eBPF 程序，然后在不同的内核上运行它【译者注：需要运行的内核也支持 BTF 内核编译选项】。</p><p><a href="https://www.ebpf.top/post/intro_vmlinux_h/" target="_blank" rel="noreferrer">https://www.ebpf.top/post/intro_vmlinux_h/</a></p><h2 id="参考资料" tabindex="-1">参考资料 <a class="header-anchor" href="#参考资料" aria-label="Permalink to &quot;参考资料&quot;">​</a></h2><ul><li><a href="https://nakryiko.com/posts/libbpf-bootstrap/" target="_blank" rel="noreferrer">Building BPF applications with libbpf-bootstrap</a></li><li><a href="https://nakryiko.com/posts/bpf-core-reference-guide/" target="_blank" rel="noreferrer">BPF CO-RE reference guide</a></li><li><a href="https://nakryiko.com/posts/bpf-portability-and-co-re/" target="_blank" rel="noreferrer">BPF CO-RE (Compile Once – Run Everywhere)</a></li></ul>',7),n=[i];function l(p,s,c,_,h,f){return r(),t("div",null,n)}const d=e(o,[["render",l]]);export{u as __pageData,d as default};

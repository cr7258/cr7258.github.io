import{_ as p}from"./chunks/ArticleMetadata.BFUCIUL_.js";import{_ as k,C as r,c as d,o as e,k as n,G as o,P as F,a as c,w as g,b as y,e as D}from"./chunks/framework.BhFhJsV2.js";import"./chunks/md5.DoUKmYou.js";const x=JSON.parse('{"title":"5 种快速查找容器中文件的方法","description":"","frontmatter":{"title":"5 种快速查找容器中文件的方法","author":"Se7en","date":"2024/07/20 19:00","categories":["个人速查手册"],"tags":["Docker"]},"headers":[],"relativePath":"categories/fragments/个人速查手册/02-find-docker-file.md","filePath":"categories/fragments/个人速查手册/02-find-docker-file.md","lastUpdated":1732242106000}'),b={name:"categories/fragments/个人速查手册/02-find-docker-file.md"};function u(i,s,m,C,f,v){const l=p,h=r("ClientOnly");return e(),d("div",null,[s[0]||(s[0]=n("h1",{id:"_5-种快速查找容器中文件的方法",tabindex:"-1"},[c("5 种快速查找容器中文件的方法 "),n("a",{class:"header-anchor",href:"#_5-种快速查找容器中文件的方法","aria-label":'Permalink to "5 种快速查找容器中文件的方法"'},"​")],-1)),o(h,null,{default:g(()=>{var a,t;return[(((a=i.$frontmatter)==null?void 0:a.aside)??!0)&&(((t=i.$frontmatter)==null?void 0:t.showArticleMetadata)??!0)?(e(),y(l,{key:0,article:i.$frontmatter},null,8,["article"])):D("",!0)]}),_:1}),s[1]||(s[1]=F(`<h2 id="创建一个示例容器" tabindex="-1">创建一个示例容器 <a class="header-anchor" href="#创建一个示例容器" aria-label="Permalink to &quot;创建一个示例容器&quot;">​</a></h2><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">docker</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> run</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> -itd</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> --name</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> mycontainer</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> busybox</span></span></code></pre></div><h2 id="方法一-exec-到容器中" tabindex="-1">方法一：Exec 到容器中 <a class="header-anchor" href="#方法一-exec-到容器中" aria-label="Permalink to &quot;方法一：Exec 到容器中&quot;">​</a></h2><p>这种方法的一个缺点是，<strong>它需要在容器中存在一个 shell</strong>。如果容器中没有/bin/bash、/bin/sh 或其他 shell，那么这种方法将不起作用。</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">docker</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> exec</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> -it</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> mycontainer</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> /bin/sh</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;"># 查看容器内文件</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">/</span><span style="--shiki-light:#6A737D;--shiki-dark:#768390;"> # ls</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">bin</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">   dev</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">   etc</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">   home</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">  proc</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">  root</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">  sys</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">   tmp</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">   usr</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">   var</span></span></code></pre></div><h2 id="方法二-使用-nsenter" tabindex="-1">方法二：使用 nsenter <a class="header-anchor" href="#方法二-使用-nsenter" aria-label="Permalink to &quot;方法二：使用 nsenter&quot;">​</a></h2><p>nsenter 命令 是一个可以在指定进程的命名空间下运行指定程序的命令。如果你再深入一点，就会意识到容器进程与 Linux 主机上的其他进程一样，只是在命名空间中运行，以使它们与系统的其他部分隔离。</p><p>首先获取容器内进程在宿主机的 PID。</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">PID</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">$(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">docker</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> container inspect mycontainer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">|</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">jq</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> &#39;.[0].State.Pid&#39;)</span></span></code></pre></div><p><img src="https://chengzw258.oss-cn-beijing.aliyuncs.com/Article/20211125093506.png" alt=""> 然后使用 nsenter 命令来进入目标容器的命名空间。<code>-m</code> 参数表示进入 mount 命名空间。<code>-t</code> 参数指定进入命名空间的目标进程的 pid。</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> nsenter</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> -m</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> -t</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> $PID </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">/bin/sh</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;"># 查看容器内文件，此时可以看到前面还有宿主机的主机名，只是进入了目标容器的命名空间</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">root@ydt-net-portainer:/</span><span style="--shiki-light:#6A737D;--shiki-dark:#768390;"> #ls</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">bin</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">   dev</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">   etc</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">   home</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">  proc</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">  root</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">  sys</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">   tmp</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">   usr</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">   var</span></span></code></pre></div><p><strong>使用 nsenter 这种方法同样要求目标容器中包含 /bin/bash（或其他 shell）。</strong></p><h2 id="方法三-使用-docker-复制" tabindex="-1">方法三：使用 docker 复制 <a class="header-anchor" href="#方法三-使用-docker-复制" aria-label="Permalink to &quot;方法三：使用 docker 复制&quot;">​</a></h2><p>可以直接将目标容器中的文件直接复制到宿主机中，<strong>不需要目标容器中包含 /bin/bash（或其他 shell）</strong>。</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">docker</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> cp</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> mycontainer:/path/to/file</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> file</span></span></code></pre></div><h2 id="方法四-在主机上查找文件系统" tabindex="-1">方法四：在主机上查找文件系统 <a class="header-anchor" href="#方法四-在主机上查找文件系统" aria-label="Permalink to &quot;方法四：在主机上查找文件系统&quot;">​</a></h2><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">docker</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> container</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> inspect</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> mycontainer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> jq</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> &#39;.[0].GraphDriver&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;"># 返回结果</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">{</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">		&quot;Data&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">			&quot;LowerDir&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> &quot;/var/lib/docker/overlay2/28efaabd0fb7ee3b42f8799e42752aa5fed96a5094064a044c9f410a29398ce7-init/diff:/var/lib/docker/overlay2/72c0b407cb9f4c080754b4377abc210726188d3941599456101a047d6ba6f002/diff&quot;,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">			&quot;MergedDir&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> &quot;/var/lib/docker/overlay2/28efaabd0fb7ee3b42f8799e42752aa5fed96a5094064a044c9f410a29398ce7/merged&quot;,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">			&quot;UpperDir&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> &quot;/var/lib/docker/overlay2/28efaabd0fb7ee3b42f8799e42752aa5fed96a5094064a044c9f410a29398ce7/diff&quot;,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">			&quot;WorkDir&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> &quot;/var/lib/docker/overlay2/28efaabd0fb7ee3b42f8799e42752aa5fed96a5094064a044c9f410a29398ce7/work&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">		},</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">		&quot;Name&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> &quot;overlay2&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>让我们来分析一下：</p><ul><li>LowerDir：包含容器内所有层的文件系统，最后一层除外（只读）。</li><li>UpperDir：容器最上层的文件系统。这也是反映任何运行时修改的地方（读写）。</li><li>MergedDir：文件系统所有层的组合视图。</li><li>WorkDir：用于管理文件系统的内部工作目录。</li></ul><p><img src="https://chengzw258.oss-cn-beijing.aliyuncs.com/Article/20211125094631.png" alt=""></p><p>因此，要查看容器中的文件，只需查看 MergedDir 路径。这种方法<strong>不需要目标容器中包含 /bin/bash（或其他 shell）。</strong></p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">root@ydt-net-portainer:/root</span><span style="--shiki-light:#6A737D;--shiki-dark:#768390;"> #ls /var/lib/docker/overlay2/28efaabd0fb7ee3b42f8799e42752aa5fed96a5094064a044c9f410a29398ce7/merged</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">bin</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">  dev</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">  etc</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">  home</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">  proc</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">  root</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">  sys</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">  tmp</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">  usr</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">  var</span></span></code></pre></div><h2 id="方法五-proc-pid-root-推荐" tabindex="-1">方法五： <code>/proc/&lt;pid&gt;/root</code> （推荐） <a class="header-anchor" href="#方法五-proc-pid-root-推荐" aria-label="Permalink to &quot;方法五： \`/proc/&lt;pid&gt;/root\` （推荐）&quot;">​</a></h2><p>还有一种从主机找到容器文件系统的更简单的方法。使用容器内进程的宿主 PID，你可以简单地运行：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">sudo ls /proc/&lt;pid&gt;/root</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;"># 返回结果</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">root@ydt-net-portainer:/root</span><span style="--shiki-light:#6A737D;--shiki-dark:#768390;"> #sudo ls /proc/94138/root</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">bin</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">  dev</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">  etc</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">  home</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">  proc</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">  root</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">  sys</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">  tmp</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">  usr</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">  var</span></span></code></pre></div><p>Linux 已经为你提供了进程挂载命名空间的视图。</p><h2 id="参考资料" tabindex="-1">参考资料 <a class="header-anchor" href="#参考资料" aria-label="Permalink to &quot;参考资料&quot;">​</a></h2><ul><li><a href="https://mp.weixin.qq.com/s/OffLxIO0NBC5vLikfCu2Ig" target="_blank" rel="noreferrer">5 种快速查找容器文件系统中文件的方法</a></li><li><a href="https://staight.github.io/2019/09/23/nsenter%E5%91%BD%E4%BB%A4%E7%AE%80%E4%BB%8B/" target="_blank" rel="noreferrer">nsenter命令简介</a></li><li><a href="https://martinheinz.dev/blog/44" target="_blank" rel="noreferrer">Deep Dive into Docker Internals - Union Filesystem</a></li></ul>`,28))])}const _=k(b,[["render",u]]);export{x as __pageData,_ as default};

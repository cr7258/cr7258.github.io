import{_ as s,o as i,c as a,R as n}from"./chunks/framework.FHZ5yb6k.js";const F=JSON.parse('{"title":"容器","description":"","frontmatter":{"title":"容器","author":"Se7en","categories":["Interview"],"tags":["Container"]},"headers":[],"relativePath":"courses/interview/云原生/02-container.md","filePath":"courses/interview/云原生/02-container.md","lastUpdated":1729736003000}'),t={name:"courses/interview/云原生/02-container.md"},l=n(`<h2 id="容器-cpu-和内存限制在-cgroup-中的实现" tabindex="-1">容器 CPU 和内存限制在 cgroup 中的实现 <a class="header-anchor" href="#容器-cpu-和内存限制在-cgroup-中的实现" aria-label="Permalink to &quot;容器 CPU 和内存限制在 cgroup 中的实现&quot;">​</a></h2><p>在 Pod Spec 里的设置的 CPU 和内存限制，实际上是通过 cgroup 实现的。cgroup 是 Linux 内核提供的一种机制，用于限制、记录和隔离一组进程的资源使用。cgroup 通过文件系统的方式将一组进程组织在一起，并为这组进程分配资源。</p><div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">apiVersion</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">v1</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">kind</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">Pod</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">metadata</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">  name</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">frontend</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">spec</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">  containers</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  - </span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">app</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">    image</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">images.my-company.example/app:v4</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">    env</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">    resources</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">      requests</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">        memory</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;64Mi&quot;</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">        cpu</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;1&quot;</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">      limits</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">        memory</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;128Mi&quot;</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">        cpu</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;2&quot;</span></span></code></pre></div><p><strong>CPU</strong></p><ul><li><strong>CPU requests 经过转换之后会写入 cpu.share</strong>，表示这个 Cgroup 最少需要使用的 CPU。cpu.shares 这个值决定了 CPU Cgroup 子系统下控制组可用 CPU 的相对比例，不过只有当系统上 CPU 完全被占满的时候，这个比例才会在各个控制组间起作用。</li><li><strong>CPU limits 经过转换之后会写入 cpu.cfs_quota_us</strong>，表示这个 Cgroup 最多可以使用的 CPU；cpu.cfs_quota_us（一个调度周期内这个控制组被允许运行的时间） 和 cpu.cfs_period_us（CFS 算法的调度周期，一般是 100000）这两个值决定了每个控制组中所有进程的可使用 CPU 资源的最大值。例如，如果 cpu.cfs_quota_us 设置为 50000，cpu.cfs_period_us 设置为 100000，那么这个控制组中的所有进程在一个调度周期内最多只能运行 50% 的 CPU 时间。</li></ul><p><strong>内存</strong></p><ul><li>cgroup 不能直接限制内存的最少使用量。</li><li><strong>Memory limits 经过转换之后会写入 memory.limit_in_bytes</strong>， 表示这个 cgroup 最多可以使用的内存。</li></ul><p>调度只看 requests： 如果一个 Node 的 Allocatable 剩余资源大于 Pod 的 requests ，就允许这个 pod 调度到这台 node 上。limits 是限额用的，确保资源不会用超，在调度时用不到。</p><h2 id="systemd-和-cgroupfs-驱动是什么" tabindex="-1">systemd 和 cgroupfs 驱动是什么？ <a class="header-anchor" href="#systemd-和-cgroupfs-驱动是什么" aria-label="Permalink to &quot;systemd 和 cgroupfs 驱动是什么？&quot;">​</a></h2><p>kubelet 和底层容器运行时都需要对接 cgroup 来设置 Pod 和容器的 CPU、内存等资源的请求和限制。<strong>若要对接 cgroup，kubelet 和容器运行时（如 containerd, CRI-O）需要使用同一个 cgroup 驱动。</strong></p><p>kubelet 和容器运行时需使用相同的 cgroup 驱动并且采用相同的配置。同时存在两个 cgroup 管理器将造成系统中针对可用的资源和使用中的资源出现两个视图。某些情况下， 将 kubelet 和容器运行时配置为使用 cgroupfs、但为剩余的进程使用 systemd 的那些节点将在资源压力增大时变得不稳定。</p><ul><li><strong>当使用 cgroupfs 驱动时， kubelet 和容器运行时将直接对接 cgroup 文件系统来配置 cgroup。</strong></li><li>使用 systemd cgroup 驱动时，所有 cgroup-writing 操作都必须通过 systemd 的接口，不能手动修改 cgroup 文件。当 systemd 是初始化系统时， 不推荐使用 cgroupfs 驱动，因为 systemd 期望系统上只有一个 cgroup 管理器。 此外，<strong>如果你使用 cgroup v2，则应用 systemd cgroup 驱动取代 cgroupfs。</strong> 从 v1.22 开始，在使用 kubeadm 创建集群时，如果用户没有在 KubeletConfiguration 下设置 cgroupDriver 字段，kubeadm 默认使用 systemd。</li></ul><p>要将 systemd 设置为 cgroup 驱动，需编辑 KubeletConfiguration 的 cgroupDriver 选项，并将其设置为 systemd。例如：</p><div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">apiVersion</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">kubelet.config.k8s.io/v1beta1</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">kind</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">KubeletConfiguration</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;">...</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">cgroupDriver</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">systemd</span></span></code></pre></div><p>在 containerd 中，可以通过配置文件 /etc/containerd/config.toml 来设置使用 systemd cgroup 驱动。例如：</p><div class="language-toml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">toml</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">[</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">plugins</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">&quot;io</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">containerd</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">grpc</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">v1</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">cri&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">containerd</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">runtimes</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">runc</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">]</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-dark:#FF938A;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">  ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  [</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">plugins</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">&quot;io</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">containerd</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">grpc</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">v1</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">cri&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">containerd</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">runtimes</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">runc</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">options</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    SystemdCgroup = </span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">true</span></span></code></pre></div><p>参考资料</p><ul><li><a href="https://kubernetes.io/zh-cn/docs/setup/production-environment/container-runtimes/" target="_blank" rel="noreferrer">Kubernetes 官方文档：容器运行时</a></li></ul><h2 id="kubelet-的-cgroup-层级有哪些" tabindex="-1">kubelet 的 cgroup 层级有哪些？ <a class="header-anchor" href="#kubelet-的-cgroup-层级有哪些" aria-label="Permalink to &quot;kubelet 的 cgroup 层级有哪些？&quot;">​</a></h2><p><img src="https://chengzw258.oss-cn-beijing.aliyuncs.com/Article/202410182222368.png" alt=""></p><ul><li><strong>Node 级别</strong>：针对 SystemReserved、KubeReserved 和 kubepods 分别创建的三个 cgroup；cgroup v1 是按 resource controller 类型来组织目录的， 因此，/kubepods 会按 resource controller 对应到 /sys/fs/cgroup/{resource controller}/kubepods/，例如： <ul><li><code>/sys/fs/cgroup/cpu/kubepods/</code></li><li><code>/sys/fs/cgroup/memory/kubepods/</code></li></ul></li><li><strong>QoS 级别</strong>：在 kubepods cgroup 里面，又针对三种 pod QoS 分别创建一个 sub-cgroup： <ul><li>Burstable： 默认 <code>/sys/fs/cgroup/{controller}/kubepods/burstable/</code>；</li><li>BestEffort： 默认 <code>/sys/fs/cgroup/{controller}/kubepods/besteffort/</code>；</li><li>Guaranteed：这个比较特殊，直接就是 <code>/sys/fs/cgroup/{controller}/kubepods/</code>，没有单独的子目录。这是因为这种类型的 pod 都设置了 limits， 就无需再引入一层 wrapper 来防止这种类型的 pods 的资源使用总量超出限额。</li></ul></li><li><strong>Pod 级别</strong>：每个 pod 创建一个 cgroup，用来限制这个 pod 使用的总资源量；</li><li><strong>Container</strong> 级别：在 pod cgroup 内部，限制单个 container 的资源使用量。</li></ul><p>参考资料：</p><ul><li><a href="https://arthurchiao.art/blog/k8s-cgroup-zh/" target="_blank" rel="noreferrer">k8s 基于 cgroup 的资源限额（capacity enforcement）：模型设计与代码实现（2023）</a></li></ul><h2 id="pod-中有多个容器时-pod-的-requests-limits-等于各个容器-requests-limits-之和吗" tabindex="-1">Pod 中有多个容器时，Pod 的 requests/limits 等于各个容器 requests/limits 之和吗？ <a class="header-anchor" href="#pod-中有多个容器时-pod-的-requests-limits-等于各个容器-requests-limits-之和吗" aria-label="Permalink to &quot;Pod 中有多个容器时，Pod 的 requests/limits 等于各个容器 requests/limits 之和吗？&quot;">​</a></h2><p>并不是。这是因为：</p><ul><li>某些资源是这个 Pod 的所有 container 共享的；</li><li>每个 pod 也有自己的一些开销，例如 sandbox container；</li><li>Pod 级别还有一些内存等额外开销；</li></ul><p>因此，为了防止一个 pod 的多个容器使用资源超标，k8s 引入了 pod-level cgroup，每个 pod 都有自己的 cgroup。</p><p>参考资料：</p><ul><li><a href="https://arthurchiao.art/blog/k8s-cgroup-zh/" target="_blank" rel="noreferrer">k8s 基于 cgroup 的资源限额（capacity enforcement）：模型设计与代码实现（2023）</a></li></ul><h2 id="kubernetes-pod-的-qos-类型有哪几种" tabindex="-1">Kubernetes Pod 的 Qos 类型有哪几种？ <a class="header-anchor" href="#kubernetes-pod-的-qos-类型有哪几种" aria-label="Permalink to &quot;Kubernetes Pod 的 Qos 类型有哪几种？&quot;">​</a></h2><ul><li><strong>Guaranteed</strong>: requests == limits, requests != 0， 即 正常需求 == 最大需求，换言之 spec 要求的资源量必须得到保证，少一点都不行；</li><li><strong>Burstable</strong>: requests &lt; limits, requests != 0， 即 正常需求 &lt; 最大需求，资源使用量可以有一定弹性空间；</li><li><strong>BestEffort</strong>: request == limits == 0， 创建 pod 时不指定 requests/limits 就等同于设置为 0，kubelet 对这种 pod 将尽力而为；</li></ul><h2 id="container-memory-usage-bytes-和-container-memory-working-set-bytes-指标的区别是什么" tabindex="-1">container_memory_usage_bytes 和 container_memory_working_set_bytes 指标的区别是什么？ <a class="header-anchor" href="#container-memory-usage-bytes-和-container-memory-working-set-bytes-指标的区别是什么" aria-label="Permalink to &quot;container_memory_usage_bytes 和 container_memory_working_set_bytes 指标的区别是什么？&quot;">​</a></h2><ul><li><strong>container_memory_usage_bytes</strong>：表示当前容器使用的总内存量，包括所有类型的内存（例如，活跃内存、缓存和文件系统缓存等）。</li><li><strong>container_memory_working_set_bytes</strong>：通常指的是实际在使用中的内存量，不包含可以被系统回收的页面缓存。OOM Killer 会根据这个指标来决定是否终止容器以释放资源。</li></ul><p>参考资料：</p><ul><li><a href="https://faun.pub/how-much-is-too-much-the-linux-oomkiller-and-used-memory-d32186f29c9d" target="_blank" rel="noreferrer">How much is too much? The Linux OOMKiller and “used” memory</a></li></ul><h2 id="节点上怎么实现-cpu-和-内存监控的-分别监控了哪些具体的指标" tabindex="-1">节点上怎么实现 CPU 和 内存监控的，分别监控了哪些具体的指标？ <a class="header-anchor" href="#节点上怎么实现-cpu-和-内存监控的-分别监控了哪些具体的指标" aria-label="Permalink to &quot;节点上怎么实现 CPU 和 内存监控的，分别监控了哪些具体的指标？&quot;">​</a></h2><p>CPU 使用率：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span>100 - (avg by (instance) (irate(node_cpu_seconds_total{mode=&quot;idle&quot;}[5m])) * 100)</span></span></code></pre></div><p>内存使用率：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span>(node_memory_MemTotal - node_memory_MemFree - node_memory_Buffers - node_memory_Cached) / node_memory_MemTotal * 100</span></span></code></pre></div><h2 id="oom-了以后-pod-一定会被杀死吗" tabindex="-1">OOM 了以后，Pod 一定会被杀死吗？ <a class="header-anchor" href="#oom-了以后-pod-一定会被杀死吗" aria-label="Permalink to &quot;OOM 了以后，Pod 一定会被杀死吗？&quot;">​</a></h2><p>不一定。当 cgroup 超过其极限时，首先尝试从 cgroup 中回收内存，以便为 cgroup 所管理的新页面腾出空间。如果回收不成功，将调用 OOM 程序来选择并终止 cgroup 内最庞大的任务。</p><p>另外只有当 Container 中 pid 为 1 的程序被 OOM-killer 杀死时，Container 才会被标记为 OOM killed，有些应用程序可以容忍非 init 进程的 OOM kills，因此 Kubernetes 选择不跟踪非 init 进程 OOM kill 事件，这是预期的方式。</p><p>参考资料：</p><ul><li><a href="https://izsk.me/2023/02/09/Kubernetes-Out-Of-Memory-1/" target="_blank" rel="noreferrer">Kubernetes学习(kubernetes中的OOM-killer和应用程序运行时含义)</a></li><li><a href="https://mihai-albert.com/2022/02/13/out-of-memory-oom-in-kubernetes-part-2-the-oom-killer-and-application-runtime-implications/#cgroups-and-the-oom-killer" target="_blank" rel="noreferrer">Out-of-memory (OOM) in Kubernetes – Part 2: The OOM killer and application runtime implications</a></li><li><a href="https://www.kernel.org/doc/Documentation/cgroup-v1/memory.txt" target="_blank" rel="noreferrer">Memory Resource Controller: 2.5 Reclaim</a></li></ul><h2 id="为什么程序收不到-sigterm-信号" tabindex="-1">为什么程序收不到 SIGTERM 信号？ <a class="header-anchor" href="#为什么程序收不到-sigterm-信号" aria-label="Permalink to &quot;为什么程序收不到 SIGTERM 信号？&quot;">​</a></h2><p>我们的业务代码通常会捕捉 SIGTERM 信号，然后执行停止逻辑以实现优雅终止。例如以下代码：</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">package</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> main</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> (</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">  &quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">fmt</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">  &quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">os</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">  &quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">os/signal</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">  &quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">syscall</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  sigs </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">:=</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> make</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">chan</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> os.Signal, </span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  done </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">:=</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> make</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">chan</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> bool</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">  // registers the channel</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  signal.</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">Notify</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(sigs, syscall.SIGTERM)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">  go</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> func</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    sig </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">:=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> &lt;-</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">sigs</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    fmt.</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">Println</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;Caught SIGTERM, shutting down&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">    // Finish any outstanding requests, then...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    done </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&lt;-</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  }()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  fmt.</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">Println</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;Starting application&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">  // Main logic goes here</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">  &lt;-</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">done</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  fmt.</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">Println</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;exiting&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>然而业务在 Kubernetes 环境中实际运行时，有时候可能会发现在滚动更新时，我们业务的优雅终止逻辑并没有被执行，现象是在等了较长时间后，业务进程直接被 SIGKILL 强制杀死了。</p><p>通常都是因为容器启动入口使用了 shell，比如使用了类似 /bin/sh -c my-app 这样的启动入口。 或者使用 /entrypoint.sh 这样的脚本文件作为入口，在脚本中再启动业务进程。</p><p>这就可能就会导致容器内的业务进程收不到 SIGTERM 信号，原因是:</p><ul><li>容器主进程是 shell，业务进程是在 shell 中启动的，成为了 shell 进程的子进程。</li><li>shell 进程默认不会处理 SIGTERM 信号，自己不会退出，也不会将信号传递给子进程，导致业务进程不会触发停止逻辑。</li></ul><p>如何解决?</p><ul><li><strong>如果可以的话，尽量不使用 shell 启动业务进程。</strong></li><li>如果一定要通过 shell 启动，比如在启动前需要用 shell 进程一些判断和处理，或者需要启动多个进程，<strong>那么就需要在 shell 中传递下 SIGTERM 信号了</strong>，有 3 种方式可以实现：</li></ul><p><strong>1.使用 exec 命令，替换 shell 进程，这样 shell 进程就变成了主进程，直接接收到 SIGTERM 信号。</strong></p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">#! /bin/bash</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">...</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">exec</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> /bin/yourapp</span><span style="--shiki-light:#6A737D;--shiki-dark:#768390;"> # 脚本中执行二进制</span></span></code></pre></div><p><strong>2.使用 trap 命令，捕捉 SIGTERM 信号，然后转发给子进程。</strong></p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">#! /bin/bash</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">/bin/app1</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> &amp; pid1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">$!</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;</span><span style="--shiki-light:#6A737D;--shiki-dark:#768390;"> # 启动第一个业务进程并记录 pid</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">echo</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> &quot;app1 started with pid </span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">$pid1</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">/bin/app2</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> &amp; pid2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">$!</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;</span><span style="--shiki-light:#6A737D;--shiki-dark:#768390;"> # 启动第二个业务进程并记录 pid</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">echo</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> &quot;app2 started with pid </span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">$pid2</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">handle_sigterm</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">() {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">  echo</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> &quot;[INFO] Received SIGTERM&quot;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">  kill</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> -SIGTERM</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> $pid1 $pid2 </span><span style="--shiki-light:#6A737D;--shiki-dark:#768390;"># 传递 SIGTERM 给业务进程</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">  wait</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> $pid1 $pid2 </span><span style="--shiki-light:#6A737D;--shiki-dark:#768390;"># 等待所有业务进程完全终止</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">trap</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> handle_sigterm</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> SIGTERM</span><span style="--shiki-light:#6A737D;--shiki-dark:#768390;"> # 捕获 SIGTERM 信号并回调 handle_sigterm 函数</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">wait</span><span style="--shiki-light:#6A737D;--shiki-dark:#768390;"> # 等待回调执行完，主进程再退出</span></span></code></pre></div><p><strong>3.使用 tini 这样的工具，tini 是一个轻量级的 init 系统，专门用来解决容器环境下的信号处理问题。</strong></p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">FROM</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> ubuntu:22.04</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">ENV</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> TINI_VERSION</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> v0.19.0</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">ADD</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> https://github.com/krallin/tini/releases/download/</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">\${TINI_VERSION}</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">/tini</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> /tini</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">COPY</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> entrypoint.sh</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> /entrypoint.sh</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">RUN</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> chmod</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> +x</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> /tini</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> /entrypoint.sh</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">ENTRYPOINT</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> [</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;/tini&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;--&quot;]</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">CMD</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> [ </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;/start.sh&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> ]</span></span></code></pre></div><p>参考资料：</p><ul><li><a href="https://imroc.cc/kubernetes/best-practices/graceful-shutdown/sigterm#%E5%9C%A8-shell-%E4%B8%AD%E4%BC%A0%E9%80%92%E4%BF%A1%E5%8F%B7" target="_blank" rel="noreferrer">正确处理 SIGTERM 信号</a></li></ul><h2 id="docker-attach-和-docker-exec-命令有什么区别" tabindex="-1">docker attach 和 docker exec 命令有什么区别？ <a class="header-anchor" href="#docker-attach-和-docker-exec-命令有什么区别" aria-label="Permalink to &quot;docker attach 和 docker exec 命令有什么区别？&quot;">​</a></h2><p>docker attach 命令通过 shim 进程连接到容器的 stdio 流，允许用户访问容器的日志并与之交互。在 attach 的 stdin 执行 exit 命令时，容器会被停止。</p><p><img src="https://chengzw258.oss-cn-beijing.aliyuncs.com/Article/202410192058816.png" alt=""></p><p>docker exec 创建一个新的辅助容器，共享目标容器的 net, pid, mount 等命名空间、相同的 cgroups 层次结构等。从外部来看，感觉就像在现有容器内运行命令。在 exec 的 stdin 执行 exit 命令时，容器不会被停止，因为 exit 的是新创建的辅助容器。</p><p><img src="https://chengzw258.oss-cn-beijing.aliyuncs.com/Article/202410192058174.png" alt=""></p><p>参考资料：</p><ul><li><a href="https://iximiuz.com/en/posts/containers-101-attach-vs-exec/" target="_blank" rel="noreferrer">Containers 101: attach vs. exec - what&#39;s the difference?</a></li></ul><h2 id="如何正确地获取容器中的-cpu-利用率" tabindex="-1">如何正确地获取容器中的 CPU 利用率？ <a class="header-anchor" href="#如何正确地获取容器中的-cpu-利用率" aria-label="Permalink to &quot;如何正确地获取容器中的 CPU 利用率？&quot;">​</a></h2><p>在容器中如果我们使用 top 命令查看容器的 CPU 利用率，会发现其实看到是宿主机的 CPU 利用率。 这是因为在默认情况下，容器中的 <code>/proc/stat</code> 并没有单独挂载，而是使用的宿主机的。而 top 命令中对 CPU 核数的判断，以及对 CPU 利用率的显示都是根据 <code>/proc/stat</code> 文件的输出来计算的。</p><p>在容器中启动两个进程，这两个进程会尝试占满所有的 CPU 资源，从而使 CPU 使用率达到 200%。</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">yes</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> &gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> /dev/null</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> &amp;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">yes</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> &gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> /dev/null</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> &amp;</span></span></code></pre></div><p>在容器中使用 top 命令可以看到 CPU 的使用率是 0.6% + 0.6% + 21.6% + 78.1% + 21.7% + 78.3% + 29.7% + 70.3% = 300.9%，而容器的 CPU使用率其实应该是 200% 左右。</p><p><img src="https://chengzw258.oss-cn-beijing.aliyuncs.com/Article/202410222133237.png" alt=""></p><p>要想正确地获取容器中的 CPU 利用率，有 3 种方法：</p><ul><li><strong>1.使用 docker stats 命令：</strong></li></ul><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">docker</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> stats</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">CONTAINER</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> ID</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">   NAME</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">          CPU</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> %</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">     MEM</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> USAGE</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> /</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> LIMIT</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">   MEM</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> %</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">     NET</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> I/O</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">           BLOCK</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> I/O</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">       PIDS</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">3a26224e8de9</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">   funny_cohen</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">   195.48</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">%</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">   2.223</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">MiB</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> /</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 512</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">MiB</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">   0.43</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">%</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">     3.36</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">kB</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> /</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 2.52</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">kB</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">   4.1</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">kB</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> /</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 4.1</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">kB</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">   5</span></span></code></pre></div><ul><li><strong>2.找到容器所属的 cgroup，根据 <code>/sys/fs/cgroup/cpu.stat</code> (cgroup v2) 中的 <code>usage_usec</code> 来计算 CPU 利用率。</strong> 在 cgroup v1 中，根据 <code>cpuacct.usage</code> 来计算 CPU 利用率。 kubelet 中集成的 cadvisor 就是采用上述方案来获取容器的 CPU 利用率。 以 cgroup v2 为例，CPU 的使用率为 (2501959062 - 2499873874) / 1000000 * 100 = 208%，其中 1000000（微妙） 是 sleep 1 秒的时间，乘 100 是为了得到百分比。</li></ul><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">cat</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> /sys/fs/cgroup/cpu.stat</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> grep</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> usage_usec</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">sleep</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">cat</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> /sys/fs/cgroup/cpu.stat</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;"> grep</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> usage_usec</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">usage_usec</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 2499873874</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">usage_usec</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 2501959062</span></span></code></pre></div><ul><li><strong>3.使用 lxcfx 文件系统实现容器的资源视图隔离。</strong> lxcfs 是通过文件挂载的方式，把 cgroup 中关于系统的相关信息读取出来，通过 docker 的 volume 挂载给容器内部的 proc 系统。 然后让 docker 内的应用读取 proc 中信息的时候以为就是读取的宿主机的真实的 proc。下面是 lxcfs 的工作原理架构图：</li></ul><p><img src="https://chengzw258.oss-cn-beijing.aliyuncs.com/Article/202410222154271.png" alt=""></p><p>当我们把宿主机的 <code>/var/lib/lxcfs/proc/memoinfo</code> 文件挂载到 Docker 容器的 /proc/meminfo 位置后，容器中进程读取相应文件内容时，lxcfs 的 /dev/fuse 实现会从容器对应的 cgroup 中读取正确的内存限制。从而使得应用获得正确的资源约束。 CPU 的限制原理也是一样的。</p><p>lxcfx 的使用方式如下：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;"># 安装 lxcfs</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">apt-get</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> install</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> -y</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> lxcfs</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;"># 启动容器的时候将宿主机的 lxcfx 目录挂载到容器的 /proc 目录</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;"># 在容器看到 CPU 个数是--cpuset 指定的 CPU 的个数</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#F69D50;">docker</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> run</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> -it</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> --cpus</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 2</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> --cpuset-cpus</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> &quot;0,1&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> --memory</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 512</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">m</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> --rm</span><span style="--shiki-light:#005CC5;--shiki-dark:#F47067;"> \\</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">      -v</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> /var/lib/lxcfs/proc/cpuinfo:/proc/cpuinfo:rw</span><span style="--shiki-light:#005CC5;--shiki-dark:#F47067;"> \\</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">      -v</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> /var/lib/lxcfs/proc/diskstats:/proc/diskstats:rw</span><span style="--shiki-light:#005CC5;--shiki-dark:#F47067;"> \\</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">      -v</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> /var/lib/lxcfs/proc/meminfo:/proc/meminfo:rw</span><span style="--shiki-light:#005CC5;--shiki-dark:#F47067;"> \\</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">      -v</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> /var/lib/lxcfs/proc/stat:/proc/stat:rw</span><span style="--shiki-light:#005CC5;--shiki-dark:#F47067;"> \\</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">      -v</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> /var/lib/lxcfs/proc/swaps:/proc/swaps:rw</span><span style="--shiki-light:#005CC5;--shiki-dark:#F47067;"> \\</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">      -v</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> /var/lib/lxcfs/proc/uptime:/proc/uptime:rw</span><span style="--shiki-light:#005CC5;--shiki-dark:#F47067;"> \\</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">      ubuntu:18.04</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> /bin/bash</span></span></code></pre></div><p>现在在容器中运行 top 命令，就可以看到容器正确的 CPU 利用率了。</p><p><img src="https://chengzw258.oss-cn-beijing.aliyuncs.com/Article/202410222155327.png" alt=""></p><p>参考资料：</p><ul><li><a href="https://time.geekbang.org/column/article/313255" target="_blank" rel="noreferrer">06 | 容器CPU（2）：如何正确地拿到容器CPU的开销？</a></li><li><a href="https://blog.csdn.net/zhangyanfei01/article/details/129965165" target="_blank" rel="noreferrer">如何正确获取容器的CPU利用率？</a></li><li><a href="https://www.cnblogs.com/-wenli/p/14036026.html" target="_blank" rel="noreferrer">lxcfs 是什么？ 怎样通过 lxcfs 在容器内显示容器的 CPU、内存状态</a></li><li><a href="https://juejin.cn/post/6847902216511356936" target="_blank" rel="noreferrer">lxcfs 是什么？ lxcfs 实现对容器资源视图隔离的最佳实践</a></li><li><a href="https://github.com/kubernetes/enhancements/blob/d7e509453347228074f9b36ce70bcd875562c3ac/keps/sig-node/2371-cri-pod-container-stats/README.md#current-fulfiller-of-metrics-endpoints--future-proposal" target="_blank" rel="noreferrer">Current Fulfiller of Metrics Endpoints &amp; Future Proposal</a></li></ul><h2 id="为什么要做容器的资源视图隔离" tabindex="-1">为什么要做容器的资源视图隔离？ <a class="header-anchor" href="#为什么要做容器的资源视图隔离" aria-label="Permalink to &quot;为什么要做容器的资源视图隔离？&quot;">​</a></h2><ul><li>对于很多基于 JVM 的 JAVA 程序，应用启动时会根据系统的资源上限来分配 JVM 的堆和栈的大小。而在容器里面运行运行 JAVA 应用由于 JVM 获取的内存数据还是物理机的数据，而容器分配的资源配额又小于 JVM 启动时需要的资源大小，就会导致程序启动不成功。</li><li>对于需要获取 CPU 信息的程序，比如在开发 Golang 服务端需要获取 Golang 中 <code>runtime.GOMAXPROCS(runtime.NumCPU())</code> 或者运维在设置服务启动进程数量的时候（比如 Nginx 配置中的 <code>worker_processes auto</code>），都喜欢通过程序自动判断所在运行环境 CPU 的数量。但是在容器内的进程总会从 <code>/proc/cpuinfo</code> 中获取到 CPU 的核数，而容器里面的 <code>/proc</code> 文件系统还是物理机的，从而会影响到运行在容器里面服务的运行状态。</li></ul>`,91),p=[l];function e(h,k,r,o,d,g){return i(),a("div",null,p)}const u=s(t,[["render",e]]);export{F as __pageData,u as default};
